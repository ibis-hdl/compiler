/*
 * grammar_api.hpp
 *
 *  Created on: 01.03.2017
 *      Author: olaf
 */

#ifndef SOURCES_VHDL93_TEST_GRAMMAR_API_HPP_
#define SOURCES_VHDL93_TEST_GRAMMAR_API_HPP_


#include <eda/vhdl93/grammar.hpp>


/*
 * VHDL93 Grammar Test Bench API Declaration
 */
namespace eda { namespace vhdl93 {

namespace parser {

	BOOST_SPIRIT_DECLARE(abstract_literal_type);
	BOOST_SPIRIT_DECLARE(access_type_definition_type);
	BOOST_SPIRIT_DECLARE(actual_designator_type);
	BOOST_SPIRIT_DECLARE(actual_parameter_part_type);
	BOOST_SPIRIT_DECLARE(actual_part_type);
	BOOST_SPIRIT_DECLARE(adding_operator_type);
	BOOST_SPIRIT_DECLARE(aggregate_type);
	BOOST_SPIRIT_DECLARE(alias_declaration_type);
	BOOST_SPIRIT_DECLARE(alias_designator_type);
	BOOST_SPIRIT_DECLARE(allocator_type);
	BOOST_SPIRIT_DECLARE(architecture_body_type);
	BOOST_SPIRIT_DECLARE(architecture_declarative_part_type);
	BOOST_SPIRIT_DECLARE(architecture_statement_part_type);
	BOOST_SPIRIT_DECLARE(array_type_definition_type);
	BOOST_SPIRIT_DECLARE(assertion_type);
	BOOST_SPIRIT_DECLARE(assertion_statement_type);
	BOOST_SPIRIT_DECLARE(association_element_type);
	BOOST_SPIRIT_DECLARE(association_list_type);
	BOOST_SPIRIT_DECLARE(attribute_declaration_type);
	BOOST_SPIRIT_DECLARE(attribute_designator_type);
	BOOST_SPIRIT_DECLARE(attribute_name_type);
	BOOST_SPIRIT_DECLARE(attribute_specification_type);
	BOOST_SPIRIT_DECLARE(base_type);
	BOOST_SPIRIT_DECLARE(base_specifier_type);
	BOOST_SPIRIT_DECLARE(base_unit_declaration_type);
	BOOST_SPIRIT_DECLARE(based_integer_type);
	BOOST_SPIRIT_DECLARE(based_literal_type);
	BOOST_SPIRIT_DECLARE(basic_character_type);
	BOOST_SPIRIT_DECLARE(basic_graphic_character_type);
	BOOST_SPIRIT_DECLARE(basic_identifier_type);
	BOOST_SPIRIT_DECLARE(binding_indication_type);
	BOOST_SPIRIT_DECLARE(bit_string_literal_type);
	BOOST_SPIRIT_DECLARE(bit_value_type);
	BOOST_SPIRIT_DECLARE(block_configuration_type);
	BOOST_SPIRIT_DECLARE(block_declarative_item_type);
	BOOST_SPIRIT_DECLARE(block_declarative_part_type);
	BOOST_SPIRIT_DECLARE(block_header_type);
	BOOST_SPIRIT_DECLARE(block_specification_type);
	BOOST_SPIRIT_DECLARE(block_statement_type);
	BOOST_SPIRIT_DECLARE(block_statement_part_type);
	BOOST_SPIRIT_DECLARE(case_statement_type);
	BOOST_SPIRIT_DECLARE(case_statement_alternative_type);
	BOOST_SPIRIT_DECLARE(character_literal_type);
	BOOST_SPIRIT_DECLARE(choice_type);
	BOOST_SPIRIT_DECLARE(choices_type);
	BOOST_SPIRIT_DECLARE(component_configuration_type);
	BOOST_SPIRIT_DECLARE(component_declaration_type);
	BOOST_SPIRIT_DECLARE(component_instantiation_statement_type);
	BOOST_SPIRIT_DECLARE(component_specification_type);
	BOOST_SPIRIT_DECLARE(composite_type_definition_type);
	BOOST_SPIRIT_DECLARE(concurrent_assertion_statement_type);
	BOOST_SPIRIT_DECLARE(concurrent_procedure_call_statement_type);
	BOOST_SPIRIT_DECLARE(concurrent_signal_assignment_statement_type);
	BOOST_SPIRIT_DECLARE(concurrent_statement_type);
	BOOST_SPIRIT_DECLARE(condition_type);
	BOOST_SPIRIT_DECLARE(condition_clause_type);
	BOOST_SPIRIT_DECLARE(conditional_signal_assignment_type);
	BOOST_SPIRIT_DECLARE(conditional_waveforms_type);
	BOOST_SPIRIT_DECLARE(configuration_declaration_type);
	BOOST_SPIRIT_DECLARE(configuration_declarative_item_type);
	BOOST_SPIRIT_DECLARE(configuration_declarative_part_type);
	BOOST_SPIRIT_DECLARE(configuration_item_type);
	BOOST_SPIRIT_DECLARE(configuration_specification_type);
	BOOST_SPIRIT_DECLARE(constant_declaration_type);
	BOOST_SPIRIT_DECLARE(constrained_array_definition_type);
	BOOST_SPIRIT_DECLARE(constraint_type);
	BOOST_SPIRIT_DECLARE(context_clause_type);
	BOOST_SPIRIT_DECLARE(context_item_type);
	BOOST_SPIRIT_DECLARE(decimal_literal_type);
	BOOST_SPIRIT_DECLARE(declaration_type);
	BOOST_SPIRIT_DECLARE(delay_mechanism_type);
	BOOST_SPIRIT_DECLARE(design_file_type);
	BOOST_SPIRIT_DECLARE(design_unit_type);
	BOOST_SPIRIT_DECLARE(designator_type);
	BOOST_SPIRIT_DECLARE(direction_type);
	BOOST_SPIRIT_DECLARE(disconnection_specification_type);
	BOOST_SPIRIT_DECLARE(discrete_range_type);
	BOOST_SPIRIT_DECLARE(element_association_type);
	BOOST_SPIRIT_DECLARE(element_declaration_type);
	BOOST_SPIRIT_DECLARE(element_subtype_definition_type);
	BOOST_SPIRIT_DECLARE(entity_aspect_type);
	BOOST_SPIRIT_DECLARE(entity_class_type);
	BOOST_SPIRIT_DECLARE(entity_class_entry_type);
	BOOST_SPIRIT_DECLARE(entity_class_entry_list_type);
	BOOST_SPIRIT_DECLARE(entity_declaration_type);
	BOOST_SPIRIT_DECLARE(entity_declarative_item_type);
	BOOST_SPIRIT_DECLARE(entity_declarative_part_type);
	BOOST_SPIRIT_DECLARE(entity_designator_type);
	BOOST_SPIRIT_DECLARE(entity_header_type);
	BOOST_SPIRIT_DECLARE(entity_name_list_type);
	BOOST_SPIRIT_DECLARE(entity_specification_type);
	BOOST_SPIRIT_DECLARE(entity_statement_type);
	BOOST_SPIRIT_DECLARE(entity_statement_part_type);
	BOOST_SPIRIT_DECLARE(entity_tag_type);
	BOOST_SPIRIT_DECLARE(enumeration_literal_type);
	BOOST_SPIRIT_DECLARE(enumeration_type_definition_type);
	BOOST_SPIRIT_DECLARE(exit_statement_type);
	BOOST_SPIRIT_DECLARE(exponent_type);
	BOOST_SPIRIT_DECLARE(expression_type);
	BOOST_SPIRIT_DECLARE(extended_digit_type);
	BOOST_SPIRIT_DECLARE(extended_identifier_type);
	BOOST_SPIRIT_DECLARE(factor_type);
	BOOST_SPIRIT_DECLARE(file_declaration_type);
	BOOST_SPIRIT_DECLARE(file_logical_name_type);
	BOOST_SPIRIT_DECLARE(file_open_information_type);
	BOOST_SPIRIT_DECLARE(file_type_definition_type);
	BOOST_SPIRIT_DECLARE(formal_designator_type);
	BOOST_SPIRIT_DECLARE(formal_parameter_list_type);
	BOOST_SPIRIT_DECLARE(formal_part_type);
	BOOST_SPIRIT_DECLARE(full_type_declaration_type);
	BOOST_SPIRIT_DECLARE(function_call_type);
	BOOST_SPIRIT_DECLARE(generate_statement_type);
	BOOST_SPIRIT_DECLARE(generation_scheme_type);
	BOOST_SPIRIT_DECLARE(generic_clause_type);
	BOOST_SPIRIT_DECLARE(generic_list_type);
	BOOST_SPIRIT_DECLARE(generic_map_aspect_type);
	BOOST_SPIRIT_DECLARE(graphic_character_type);
	BOOST_SPIRIT_DECLARE(group_constituent_type);
	BOOST_SPIRIT_DECLARE(group_constituent_list_type);
	BOOST_SPIRIT_DECLARE(group_template_declaration_type);
	BOOST_SPIRIT_DECLARE(group_declaration_type);
	BOOST_SPIRIT_DECLARE(guarded_signal_specification_type);
	BOOST_SPIRIT_DECLARE(identifier_type);
	BOOST_SPIRIT_DECLARE(identifier_list_type);
	BOOST_SPIRIT_DECLARE(if_statement_type);
	BOOST_SPIRIT_DECLARE(incomplete_type_declaration_type);
	BOOST_SPIRIT_DECLARE(index_constraint_type);
	BOOST_SPIRIT_DECLARE(index_specification_type);
	BOOST_SPIRIT_DECLARE(index_subtype_definition_type);
	BOOST_SPIRIT_DECLARE(indexed_name_type);
	BOOST_SPIRIT_DECLARE(instantiated_unit_type);
	BOOST_SPIRIT_DECLARE(instantiation_list_type);
	BOOST_SPIRIT_DECLARE(integer_type);
	BOOST_SPIRIT_DECLARE(integer_type_definition_type);
	BOOST_SPIRIT_DECLARE(interface_constant_declaration_type);
	BOOST_SPIRIT_DECLARE(interface_declaration_type);
	BOOST_SPIRIT_DECLARE(interface_element_type);
	BOOST_SPIRIT_DECLARE(interface_file_declaration_type);
	BOOST_SPIRIT_DECLARE(interface_list_type);
	BOOST_SPIRIT_DECLARE(interface_signal_declaration_type);
	BOOST_SPIRIT_DECLARE(interface_variable_declaration_type);
	BOOST_SPIRIT_DECLARE(iteration_scheme_type);
	BOOST_SPIRIT_DECLARE(label_type);
	BOOST_SPIRIT_DECLARE(letter_type);
	BOOST_SPIRIT_DECLARE(letter_or_digit_type);
	BOOST_SPIRIT_DECLARE(library_clause_type);
	BOOST_SPIRIT_DECLARE(library_unit_type);
	BOOST_SPIRIT_DECLARE(literal_type);
	BOOST_SPIRIT_DECLARE(logical_name_type);
	BOOST_SPIRIT_DECLARE(logical_name_list_type);
	BOOST_SPIRIT_DECLARE(logical_operator_type);
	BOOST_SPIRIT_DECLARE(loop_statement_type);
	BOOST_SPIRIT_DECLARE(miscellaneous_operator_type);
	BOOST_SPIRIT_DECLARE(mode_type);
	BOOST_SPIRIT_DECLARE(multiplying_operator_type);
	BOOST_SPIRIT_DECLARE(name_type);
	BOOST_SPIRIT_DECLARE(next_statement_type);
	BOOST_SPIRIT_DECLARE(null_statement_type);
	BOOST_SPIRIT_DECLARE(numeric_literal_type);
	BOOST_SPIRIT_DECLARE(object_declaration_type);
	BOOST_SPIRIT_DECLARE(operator_symbol_type);
	BOOST_SPIRIT_DECLARE(options_type);
	BOOST_SPIRIT_DECLARE(package_body_type);
	BOOST_SPIRIT_DECLARE(package_body_declarative_item_type);
	BOOST_SPIRIT_DECLARE(package_body_declarative_part_type);
	BOOST_SPIRIT_DECLARE(package_declaration_type);
	BOOST_SPIRIT_DECLARE(package_declarative_item_type);
	BOOST_SPIRIT_DECLARE(package_declarative_part_type);
	BOOST_SPIRIT_DECLARE(parameter_specification_type);
	BOOST_SPIRIT_DECLARE(physical_literal_type);
	BOOST_SPIRIT_DECLARE(physical_type_definition_type);
	BOOST_SPIRIT_DECLARE(port_clause_type);
	BOOST_SPIRIT_DECLARE(port_list_type);
	BOOST_SPIRIT_DECLARE(port_map_aspect_type);
	BOOST_SPIRIT_DECLARE(prefix_type);
	BOOST_SPIRIT_DECLARE(primary_type);
	BOOST_SPIRIT_DECLARE(primary_unit_type);
	BOOST_SPIRIT_DECLARE(procedure_call_type);
	BOOST_SPIRIT_DECLARE(procedure_call_statement_type);
	BOOST_SPIRIT_DECLARE(process_declarative_item_type);
	BOOST_SPIRIT_DECLARE(process_declarative_part_type);
	BOOST_SPIRIT_DECLARE(process_statement_type);
	BOOST_SPIRIT_DECLARE(process_statement_part_type);
	BOOST_SPIRIT_DECLARE(qualified_expression_type);
	BOOST_SPIRIT_DECLARE(range_type);
	BOOST_SPIRIT_DECLARE(range_constraint_type);
	BOOST_SPIRIT_DECLARE(record_type_definition_type);
	BOOST_SPIRIT_DECLARE(relation_type);
	BOOST_SPIRIT_DECLARE(relational_operator_type);
	BOOST_SPIRIT_DECLARE(report_statement_type);
	BOOST_SPIRIT_DECLARE(return_statement_type);
	BOOST_SPIRIT_DECLARE(scalar_type_definition_type);
	BOOST_SPIRIT_DECLARE(secondary_unit_type);
	BOOST_SPIRIT_DECLARE(secondary_unit_declaration_type);
	BOOST_SPIRIT_DECLARE(selected_name_type);
	BOOST_SPIRIT_DECLARE(selected_signal_assignment_type);
	BOOST_SPIRIT_DECLARE(selected_waveforms_type);
	BOOST_SPIRIT_DECLARE(sensitivity_clause_type);
	BOOST_SPIRIT_DECLARE(sensitivity_list_type);
	BOOST_SPIRIT_DECLARE(sequence_of_statements_type);
	BOOST_SPIRIT_DECLARE(sequential_statement_type);
	BOOST_SPIRIT_DECLARE(shift_expression_type);
	BOOST_SPIRIT_DECLARE(shift_operator_type);
	BOOST_SPIRIT_DECLARE(sign_type);
	BOOST_SPIRIT_DECLARE(signal_assignment_statement_type);
	BOOST_SPIRIT_DECLARE(signal_declaration_type);
	BOOST_SPIRIT_DECLARE(signal_kind_type);
	BOOST_SPIRIT_DECLARE(signal_list_type);
	BOOST_SPIRIT_DECLARE(signature_type);
	BOOST_SPIRIT_DECLARE(simple_expression_type);
	BOOST_SPIRIT_DECLARE(simple_name_type);
	BOOST_SPIRIT_DECLARE(slice_name_type);
	BOOST_SPIRIT_DECLARE(string_literal_type);
	BOOST_SPIRIT_DECLARE(subprogram_body_type);
	BOOST_SPIRIT_DECLARE(subprogram_declaration_type);
	BOOST_SPIRIT_DECLARE(subprogram_declarative_item_type);
	BOOST_SPIRIT_DECLARE(subprogram_declarative_part_type);
	BOOST_SPIRIT_DECLARE(subprogram_kind_type);
	BOOST_SPIRIT_DECLARE(subprogram_specification_type);
	BOOST_SPIRIT_DECLARE(subprogram_statement_part_type);
	BOOST_SPIRIT_DECLARE(subtype_declaration_type);
	BOOST_SPIRIT_DECLARE(subtype_indication_type);
	BOOST_SPIRIT_DECLARE(suffix_type);
	BOOST_SPIRIT_DECLARE(target_type);
	BOOST_SPIRIT_DECLARE(term_type);
	BOOST_SPIRIT_DECLARE(timeout_clause_type);
	BOOST_SPIRIT_DECLARE(type_conversion_type);
	BOOST_SPIRIT_DECLARE(type_declaration_type);
	BOOST_SPIRIT_DECLARE(type_definition_type);
	BOOST_SPIRIT_DECLARE(type_mark_type);
	BOOST_SPIRIT_DECLARE(unconstrained_array_definition_type);
	BOOST_SPIRIT_DECLARE(use_clause_type);
	BOOST_SPIRIT_DECLARE(variable_assignment_statement_type);
	BOOST_SPIRIT_DECLARE(variable_declaration_type);
	BOOST_SPIRIT_DECLARE(wait_statement_type);
	BOOST_SPIRIT_DECLARE(waveform_type);

} // namespace parser

parser::abstract_literal_type const& abstract_literal();
parser::access_type_definition_type const& access_type_definition();
parser::actual_designator_type const& actual_designator();
parser::actual_parameter_part_type const& actual_parameter_part();
parser::actual_part_type const& actual_part();
parser::adding_operator_type const& adding_operator();
parser::aggregate_type const& aggregate();
parser::alias_declaration_type const& alias_declaration();
parser::alias_designator_type const& alias_designator();
parser::allocator_type const& allocator();
parser::architecture_body_type const& architecture_body();
parser::architecture_declarative_part_type const& architecture_declarative_part();
parser::architecture_statement_part_type const& architecture_statement_part();
parser::array_type_definition_type const& array_type_definition();
parser::assertion_type const& assertion();
parser::assertion_statement_type const& assertion_statement();
parser::association_element_type const& association_element();
parser::association_list_type const& association_list();
parser::attribute_declaration_type const& attribute_declaration();
parser::attribute_designator_type const& attribute_designator();
parser::attribute_name_type const& attribute_name();
parser::attribute_specification_type const& attribute_specification();
parser::base_type const& base();
parser::base_specifier_type const& base_specifier();
parser::base_unit_declaration_type const& base_unit_declaration();
parser::based_integer_type const& based_integer();
parser::based_literal_type const& based_literal();
parser::basic_character_type const& basic_character();
parser::basic_graphic_character_type const& basic_graphic_character();
parser::basic_identifier_type const& basic_identifier();
parser::binding_indication_type const& binding_indication();
parser::bit_string_literal_type const& bit_string_literal();
parser::bit_value_type const& bit_value();
parser::block_configuration_type const& block_configuration();
parser::block_declarative_item_type const& block_declarative_item();
parser::block_declarative_part_type const& block_declarative_part();
parser::block_header_type const& block_header();
parser::block_specification_type const& block_specification();
parser::block_statement_type const& block_statement();
parser::block_statement_part_type const& block_statement_part();
parser::case_statement_type const& case_statement();
parser::case_statement_alternative_type const& case_statement_alternative();
parser::character_literal_type const& character_literal();
parser::choice_type const& choice();
parser::choices_type const& choices();
parser::component_configuration_type const& component_configuration();
parser::component_declaration_type const& component_declaration();
parser::component_instantiation_statement_type const& component_instantiation_statement();
parser::component_specification_type const& component_specification();
parser::composite_type_definition_type const& composite_type_definition();
parser::concurrent_assertion_statement_type const& concurrent_assertion_statement();
parser::concurrent_procedure_call_statement_type const& concurrent_procedure_call_statement();
parser::concurrent_signal_assignment_statement_type const& concurrent_signal_assignment_statement();
parser::concurrent_statement_type const& concurrent_statement();
parser::condition_type const& condition();
parser::condition_clause_type const& condition_clause();
parser::conditional_signal_assignment_type const& conditional_signal_assignment();
parser::conditional_waveforms_type const& conditional_waveforms();
parser::configuration_declaration_type const& configuration_declaration();
parser::configuration_declarative_item_type const& configuration_declarative_item();
parser::configuration_declarative_part_type const& configuration_declarative_part();
parser::configuration_item_type const& configuration_item();
parser::configuration_specification_type const& configuration_specification();
parser::constant_declaration_type const& constant_declaration();
parser::constrained_array_definition_type const& constrained_array_definition();
parser::constraint_type const& constraint();
parser::context_clause_type const& context_clause();
parser::context_item_type const& context_item();
parser::decimal_literal_type const& decimal_literal();
parser::declaration_type const& declaration();
parser::delay_mechanism_type const& delay_mechanism();
parser::design_file_type const& design_file();
parser::design_unit_type const& design_unit();
parser::designator_type const& designator();
parser::direction_type const& direction();
parser::disconnection_specification_type const& disconnection_specification();
parser::discrete_range_type const& discrete_range();
parser::element_association_type const& element_association();
parser::element_declaration_type const& element_declaration();
parser::element_subtype_definition_type const& element_subtype_definition();
parser::entity_aspect_type const& entity_aspect();
parser::entity_class_type const& entity_class();
parser::entity_class_entry_type const& entity_class_entry();
parser::entity_class_entry_list_type const& entity_class_entry_list();
parser::entity_declaration_type const& entity_declaration();
parser::entity_declarative_item_type const& entity_declarative_item();
parser::entity_declarative_part_type const& entity_declarative_part();
parser::entity_designator_type const& entity_designator();
parser::entity_header_type const& entity_header();
parser::entity_name_list_type const& entity_name_list();
parser::entity_specification_type const& entity_specification();
parser::entity_statement_type const& entity_statement();
parser::entity_statement_part_type const& entity_statement_part();
parser::entity_tag_type const& entity_tag();
parser::enumeration_literal_type const& enumeration_literal();
parser::enumeration_type_definition_type const& enumeration_type_definition();
parser::exit_statement_type const& exit_statement();
parser::exponent_type const& exponent();
parser::expression_type const& expression();
parser::extended_digit_type const& extended_digit();
parser::extended_identifier_type const& extended_identifier();
parser::factor_type const& factor();
parser::file_declaration_type const& file_declaration();
parser::file_logical_name_type const& file_logical_name();
parser::file_open_information_type const& file_open_information();
parser::file_type_definition_type const& file_type_definition();
parser::formal_designator_type const& formal_designator();
parser::formal_parameter_list_type const& formal_parameter_list();
parser::formal_part_type const& formal_part();
parser::full_type_declaration_type const& full_type_declaration();
parser::function_call_type const& function_call();
parser::generate_statement_type const& generate_statement();
parser::generation_scheme_type const& generation_scheme();
parser::generic_clause_type const& generic_clause();
parser::generic_list_type const& generic_list();
parser::generic_map_aspect_type const& generic_map_aspect();
parser::graphic_character_type const& graphic_character();
parser::group_constituent_type const& group_constituent();
parser::group_constituent_list_type const& group_constituent_list();
parser::group_template_declaration_type const& group_template_declaration();
parser::group_declaration_type const& group_declaration();
parser::guarded_signal_specification_type const& guarded_signal_specification();
parser::identifier_type const& identifier();
parser::identifier_list_type const& identifier_list();
parser::if_statement_type const& if_statement();
parser::incomplete_type_declaration_type const& incomplete_type_declaration();
parser::index_constraint_type const& index_constraint();
parser::index_specification_type const& index_specification();
parser::index_subtype_definition_type const& index_subtype_definition();
parser::indexed_name_type const& indexed_name();
parser::instantiated_unit_type const& instantiated_unit();
parser::instantiation_list_type const& instantiation_list();
parser::integer_type const& integer();
parser::integer_type_definition_type const& integer_type_definition();
parser::interface_constant_declaration_type const& interface_constant_declaration();
parser::interface_declaration_type const& interface_declaration();
parser::interface_element_type const& interface_element();
parser::interface_file_declaration_type const& interface_file_declaration();
parser::interface_list_type const& interface_list();
parser::interface_signal_declaration_type const& interface_signal_declaration();
parser::interface_variable_declaration_type const& interface_variable_declaration();
parser::iteration_scheme_type const& iteration_scheme();
parser::label_type const& label();
parser::letter_type const& letter();
parser::letter_or_digit_type const& letter_or_digit();
parser::library_clause_type const& library_clause();
parser::library_unit_type const& library_unit();
parser::literal_type const& literal();
parser::logical_name_type const& logical_name();
parser::logical_name_list_type const& logical_name_list();
parser::logical_operator_type const& logical_operator();
parser::loop_statement_type const& loop_statement();
parser::miscellaneous_operator_type const& miscellaneous_operator();
parser::mode_type const& mode();
parser::multiplying_operator_type const& multiplying_operator();
parser::name_type const& name();
parser::next_statement_type const& next_statement();
parser::null_statement_type const& null_statement();
parser::numeric_literal_type const& numeric_literal();
parser::object_declaration_type const& object_declaration();
parser::operator_symbol_type const& operator_symbol();
parser::options_type const& options();
parser::package_body_type const& package_body();
parser::package_body_declarative_item_type const& package_body_declarative_item();
parser::package_body_declarative_part_type const& package_body_declarative_part();
parser::package_declaration_type const& package_declaration();
parser::package_declarative_item_type const& package_declarative_item();
parser::package_declarative_part_type const& package_declarative_part();
parser::parameter_specification_type const& parameter_specification();
parser::physical_literal_type const& physical_literal();
parser::physical_type_definition_type const& physical_type_definition();
parser::port_clause_type const& port_clause();
parser::port_list_type const& port_list();
parser::port_map_aspect_type const& port_map_aspect();
parser::prefix_type const& prefix();
parser::primary_type const& primary();
parser::primary_unit_type const& primary_unit();
parser::procedure_call_type const& procedure_call();
parser::procedure_call_statement_type const& procedure_call_statement();
parser::process_declarative_item_type const& process_declarative_item();
parser::process_declarative_part_type const& process_declarative_part();
parser::process_statement_type const& process_statement();
parser::process_statement_part_type const& process_statement_part();
parser::qualified_expression_type const& qualified_expression();
parser::range_type const& range();
parser::range_constraint_type const& range_constraint();
parser::record_type_definition_type const& record_type_definition();
parser::relation_type const& relation();
parser::relational_operator_type const& relational_operator();
parser::report_statement_type const& report_statement();
parser::return_statement_type const& return_statement();
parser::scalar_type_definition_type const& scalar_type_definition();
parser::secondary_unit_type const& secondary_unit();
parser::secondary_unit_declaration_type const& secondary_unit_declaration();
parser::selected_name_type const& selected_name();
parser::selected_signal_assignment_type const& selected_signal_assignment();
parser::selected_waveforms_type const& selected_waveforms();
parser::sensitivity_clause_type const& sensitivity_clause();
parser::sensitivity_list_type const& sensitivity_list();
parser::sequence_of_statements_type const& sequence_of_statements();
parser::sequential_statement_type const& sequential_statement();
parser::shift_expression_type const& shift_expression();
parser::shift_operator_type const& shift_operator();
parser::sign_type const& sign();
parser::signal_assignment_statement_type const& signal_assignment_statement();
parser::signal_declaration_type const& signal_declaration();
parser::signal_kind_type const& signal_kind();
parser::signal_list_type const& signal_list();
parser::signature_type const& signature();
parser::simple_expression_type const& simple_expression();
parser::simple_name_type const& simple_name();
parser::slice_name_type const& slice_name();
parser::string_literal_type const& string_literal();
parser::subprogram_body_type const& subprogram_body();
parser::subprogram_declaration_type const& subprogram_declaration();
parser::subprogram_declarative_item_type const& subprogram_declarative_item();
parser::subprogram_declarative_part_type const& subprogram_declarative_part();
parser::subprogram_kind_type const& subprogram_kind();
parser::subprogram_specification_type const& subprogram_specification();
parser::subprogram_statement_part_type const& subprogram_statement_part();
parser::subtype_declaration_type const& subtype_declaration();
parser::subtype_indication_type const& subtype_indication();
parser::suffix_type const& suffix();
parser::target_type const& target();
parser::term_type const& term();
parser::timeout_clause_type const& timeout_clause();
parser::type_conversion_type const& type_conversion();
parser::type_declaration_type const& type_declaration();
parser::type_definition_type const& type_definition();
parser::type_mark_type const& type_mark();
parser::unconstrained_array_definition_type const& unconstrained_array_definition();
parser::use_clause_type const& use_clause();
parser::variable_assignment_statement_type const& variable_assignment_statement();
parser::variable_declaration_type const& variable_declaration();
parser::wait_statement_type const& wait_statement();
parser::waveform_type const& waveform();

} } // namespace eda.vhdl93




#endif /* SOURCES_VHDL93_TEST_GRAMMAR_API_HPP_ */
