/*
 * abstract_literal.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ABSTRACT_LITERAL_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ABSTRACT_LITERAL_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct based_literal;
struct decimal_literal;

struct abstract_literal :
    x3::variant<
        x3::forward_ast<based_literal>,
        x3::forward_ast<decimal_literal>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ABSTRACT_LITERAL_HPP_ */


/*
 * access_type_definition.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACCESS_TYPE_DEFINITION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACCESS_TYPE_DEFINITION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct access;
struct subtype_indication;

struct access_type_definition : x3::position_tagged
{
    access              access;             
    subtype_indication  subtype_indication; 
};


std::ostream& operator<<(std::ostream& os, access_type_definition const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACCESS_TYPE_DEFINITION_HPP_ */


/*
 * actual_designator.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_DESIGNATOR_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_DESIGNATOR_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct expression;
struct file_name;
struct open;
struct signal_name;
struct variable_name;

struct actual_designator :
    x3::variant<
        x3::forward_ast<expression>,
        x3::forward_ast<file_name>,
        x3::forward_ast<open>,
        x3::forward_ast<signal_name>,
        x3::forward_ast<variable_name>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_DESIGNATOR_HPP_ */


/*
 * actual_parameter_part.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_PARAMETER_PART_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_PARAMETER_PART_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct parameter_association_list;

struct actual_parameter_part : x3::position_tagged
{
    parameter_association_listparameter_association_list;
};


std::ostream& operator<<(std::ostream& os, actual_parameter_part const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_PARAMETER_PART_HPP_ */


/*
 * actual_part.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_PART_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_PART_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct actual_designator;
struct function_name;
struct type_mark;

struct actual_part :
    x3::variant<
        x3::forward_ast<actual_designator>,
        x3::forward_ast<function_name>,
        x3::forward_ast<type_mark>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ACTUAL_PART_HPP_ */


/*
 * aggregate.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_AGGREGATE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_AGGREGATE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct element_association;

struct aggregate : x3::position_tagged
{
    element_association element_association;
};


std::ostream& operator<<(std::ostream& os, aggregate const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_AGGREGATE_HPP_ */


/*
 * alias_declaration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALIAS_DECLARATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALIAS_DECLARATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct alias;
struct alias_designator;
struct is;
struct name;
struct signature;
struct subtype_indication;

struct alias_declaration : x3::position_tagged
{
    alias               alias;              
    alias_designator    alias_designator;   
    is                  is;                 
    name                name;               
    signature           signature;          
    subtype_indication  subtype_indication; 
};


std::ostream& operator<<(std::ostream& os, alias_declaration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALIAS_DECLARATION_HPP_ */


/*
 * alias_designator.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALIAS_DESIGNATOR_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALIAS_DESIGNATOR_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct character_literal;
struct identifier;
struct operator_symbol;

struct alias_designator :
    x3::variant<
        x3::forward_ast<character_literal>,
        x3::forward_ast<identifier>,
        x3::forward_ast<operator_symbol>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALIAS_DESIGNATOR_HPP_ */


/*
 * allocator.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALLOCATOR_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALLOCATOR_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct new;
struct qualified_expression;
struct subtype_indication;

struct allocator :
    x3::variant<
        x3::forward_ast<new>,
        x3::forward_ast<qualified_expression>,
        x3::forward_ast<subtype_indication>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ALLOCATOR_HPP_ */


/*
 * architecture_body.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_BODY_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_BODY_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct architecture;
struct architecture_declarative_part;
struct architecture_simple_name;
struct architecture_statement_part;
struct begin;
struct end;
struct entity_name;
struct identifier;
struct is;
struct of;

struct architecture_body : x3::position_tagged
{
    architecture        architecture;       
    architecture_declarative_partarchitecture_declarative_part;
    architecture_simple_namearchitecture_simple_name;
    architecture_statement_partarchitecture_statement_part;
    begin               begin;              
    end                 end;                
    entity_name         entity_name;        
    identifier          identifier;         
    is                  is;                 
    of                  of;                 
};


std::ostream& operator<<(std::ostream& os, architecture_body const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_BODY_HPP_ */


/*
 * architecture_declarative_part.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_DECLARATIVE_PART_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_DECLARATIVE_PART_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct block_declarative_item;

struct architecture_declarative_part : x3::position_tagged
{
    block_declarative_itemblock_declarative_item;
};


std::ostream& operator<<(std::ostream& os, architecture_declarative_part const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_DECLARATIVE_PART_HPP_ */


/*
 * architecture_statement_part.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_STATEMENT_PART_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_STATEMENT_PART_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct concurrent_statement;

struct architecture_statement_part : x3::position_tagged
{
    concurrent_statementconcurrent_statement;
};


std::ostream& operator<<(std::ostream& os, architecture_statement_part const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARCHITECTURE_STATEMENT_PART_HPP_ */


/*
 * array_type_definition.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARRAY_TYPE_DEFINITION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARRAY_TYPE_DEFINITION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct constrained_array_definition;
struct unconstrained_array_definition;

struct array_type_definition :
    x3::variant<
        x3::forward_ast<constrained_array_definition>,
        x3::forward_ast<unconstrained_array_definition>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ARRAY_TYPE_DEFINITION_HPP_ */


/*
 * assertion.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSERTION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSERTION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct assert;
struct condition;
struct expression;
struct report;
struct severity;

struct assertion : x3::position_tagged
{
    assert              assert;             
    condition           condition;          
    expression          expression;         
    report              report;             
    severity            severity;           
};


std::ostream& operator<<(std::ostream& os, assertion const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSERTION_HPP_ */


/*
 * assertion_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSERTION_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSERTION_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct assertion;
struct label;

struct assertion_statement : x3::position_tagged
{
    assertion           assertion;          
    label               label;              
};


std::ostream& operator<<(std::ostream& os, assertion_statement const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSERTION_STATEMENT_HPP_ */


/*
 * association_element.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSOCIATION_ELEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSOCIATION_ELEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct actual_part;
struct formal_part;

struct association_element : x3::position_tagged
{
    actual_part         actual_part;        
    formal_part         formal_part;        
};


std::ostream& operator<<(std::ostream& os, association_element const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSOCIATION_ELEMENT_HPP_ */


/*
 * association_list.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSOCIATION_LIST_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSOCIATION_LIST_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct association_element;

struct association_list : x3::position_tagged
{
    association_element association_element;
};


std::ostream& operator<<(std::ostream& os, association_list const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ASSOCIATION_LIST_HPP_ */


/*
 * attribute_declaration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_DECLARATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_DECLARATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct attribute;
struct identifier;
struct type_mark;

struct attribute_declaration : x3::position_tagged
{
    attribute           attribute;          
    identifier          identifier;         
    type_mark           type_mark;          
};


std::ostream& operator<<(std::ostream& os, attribute_declaration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_DECLARATION_HPP_ */


/*
 * attribute_designator.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_DESIGNATOR_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_DESIGNATOR_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct attribute_simple_name;

struct attribute_designator : x3::position_tagged
{
    attribute_simple_nameattribute_simple_name;
};


std::ostream& operator<<(std::ostream& os, attribute_designator const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_DESIGNATOR_HPP_ */


/*
 * attribute_name.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_NAME_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_NAME_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct attribute_designator;
struct expression;
struct prefix;
struct signature;

struct attribute_name : x3::position_tagged
{
    attribute_designatorattribute_designator;
    expression          expression;         
    prefix              prefix;             
    signature           signature;          
};


std::ostream& operator<<(std::ostream& os, attribute_name const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_NAME_HPP_ */


/*
 * attribute_specification.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_SPECIFICATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_SPECIFICATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct attribute;
struct attribute_designator;
struct entity_specification;
struct expression;
struct is;
struct of;

struct attribute_specification : x3::position_tagged
{
    attribute           attribute;          
    attribute_designatorattribute_designator;
    entity_specificationentity_specification;
    expression          expression;         
    is                  is;                 
    of                  of;                 
};


std::ostream& operator<<(std::ostream& os, attribute_specification const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_ATTRIBUTE_SPECIFICATION_HPP_ */


/*
 * base.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct integer;

struct base : x3::position_tagged
{
    integer             integer;            
};


std::ostream& operator<<(std::ostream& os, base const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_HPP_ */


/*
 * base_specifier.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_SPECIFIER_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_SPECIFIER_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct B;
struct O;
struct X;

struct base_specifier :
    x3::variant<
        x3::forward_ast<B>,
        x3::forward_ast<O>,
        x3::forward_ast<X>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_SPECIFIER_HPP_ */


/*
 * base_unit_declaration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_UNIT_DECLARATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_UNIT_DECLARATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct identifier;

struct base_unit_declaration : x3::position_tagged
{
    identifier          identifier;         
};


std::ostream& operator<<(std::ostream& os, base_unit_declaration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASE_UNIT_DECLARATION_HPP_ */


/*
 * based_integer.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASED_INTEGER_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASED_INTEGER_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct extended_digit;
struct underline;

struct based_integer : x3::position_tagged
{
    extended_digit      extended_digit;     
    underline           underline;          
};


std::ostream& operator<<(std::ostream& os, based_integer const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASED_INTEGER_HPP_ */


/*
 * based_literal.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASED_LITERAL_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASED_LITERAL_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct base;
struct based_integer;
struct exponent;

struct based_literal : x3::position_tagged
{
    base                base;               
    based_integer       based_integer;      
    exponent            exponent;           
};


std::ostream& operator<<(std::ostream& os, based_literal const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASED_LITERAL_HPP_ */


/*
 * basic_character.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_CHARACTER_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_CHARACTER_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct basic_graphic_character;
struct format_effector;

struct basic_character :
    x3::variant<
        x3::forward_ast<basic_graphic_character>,
        x3::forward_ast<format_effector>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_CHARACTER_HPP_ */


/*
 * basic_graphic_character.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_GRAPHIC_CHARACTER_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_GRAPHIC_CHARACTER_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct digit;
struct space_character;
struct special_character|;
struct upper_case_letter;

struct basic_graphic_character :
    x3::variant<
        x3::forward_ast<digit>,
        x3::forward_ast<space_character>,
        x3::forward_ast<special_character|>,
        x3::forward_ast<upper_case_letter>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_GRAPHIC_CHARACTER_HPP_ */


/*
 * basic_identifier.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_IDENTIFIER_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_IDENTIFIER_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct letter;
struct letter_or_digit;
struct underline;

struct basic_identifier : x3::position_tagged
{
    letter              letter;             
    letter_or_digit     letter_or_digit;    
    underline           underline;          
};


std::ostream& operator<<(std::ostream& os, basic_identifier const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BASIC_IDENTIFIER_HPP_ */


/*
 * binding_indication.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BINDING_INDICATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BINDING_INDICATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct entity_aspect;
struct generic_map_aspect;
struct port_map_aspect;
struct use;

struct binding_indication : x3::position_tagged
{
    entity_aspect       entity_aspect;      
    generic_map_aspect  generic_map_aspect; 
    port_map_aspect     port_map_aspect;    
    use                 use;                
};


std::ostream& operator<<(std::ostream& os, binding_indication const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BINDING_INDICATION_HPP_ */


/*
 * bit_string_literal.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BIT_STRING_LITERAL_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BIT_STRING_LITERAL_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct base_specifier;
struct bit_value;

struct bit_string_literal : x3::position_tagged
{
    base_specifier      base_specifier;     
    bit_value           bit_value;          
};


std::ostream& operator<<(std::ostream& os, bit_string_literal const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BIT_STRING_LITERAL_HPP_ */


/*
 * bit_value.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BIT_VALUE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BIT_VALUE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct extended_digit;
struct underline;

struct bit_value : x3::position_tagged
{
    extended_digit      extended_digit;     
    underline           underline;          
};


std::ostream& operator<<(std::ostream& os, bit_value const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BIT_VALUE_HPP_ */


/*
 * block_configuration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_CONFIGURATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_CONFIGURATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct block_specification;
struct configuration_item;
struct end;
struct for;
struct use_clause;

struct block_configuration : x3::position_tagged
{
    block_specification block_specification;
    configuration_item  configuration_item; 
    end                 end;                
    for                 for;                
    use_clause          use_clause;         
};


std::ostream& operator<<(std::ostream& os, block_configuration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_CONFIGURATION_HPP_ */


/*
 * block_declarative_item.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_DECLARATIVE_ITEM_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_DECLARATIVE_ITEM_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct alias_declaration;
struct attribute_declaration;
struct attribute_specification;
struct component_declaration;
struct configuration_specification;
struct constant_declaration;
struct disconnection_specification;
struct file_declaration;
struct group_declaration;
struct group_template_declaration;
struct shared_variable_declaration;
struct signal_declaration;
struct subprogram_body;
struct subprogram_declaration;
struct subtype_declaration;
struct type_declaration;
struct use_clause;

struct block_declarative_item :
    x3::variant<
        x3::forward_ast<alias_declaration>,
        x3::forward_ast<attribute_declaration>,
        x3::forward_ast<attribute_specification>,
        x3::forward_ast<component_declaration>,
        x3::forward_ast<configuration_specification>,
        x3::forward_ast<constant_declaration>,
        x3::forward_ast<disconnection_specification>,
        x3::forward_ast<file_declaration>,
        x3::forward_ast<group_declaration>,
        x3::forward_ast<group_template_declaration>,
        x3::forward_ast<shared_variable_declaration>,
        x3::forward_ast<signal_declaration>,
        x3::forward_ast<subprogram_body>,
        x3::forward_ast<subprogram_declaration>,
        x3::forward_ast<subtype_declaration>,
        x3::forward_ast<type_declaration>,
        x3::forward_ast<use_clause>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_DECLARATIVE_ITEM_HPP_ */


/*
 * block_declarative_part.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_DECLARATIVE_PART_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_DECLARATIVE_PART_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct block_declarative_item;

struct block_declarative_part : x3::position_tagged
{
    block_declarative_itemblock_declarative_item;
};


std::ostream& operator<<(std::ostream& os, block_declarative_part const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_DECLARATIVE_PART_HPP_ */


/*
 * block_header.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_HEADER_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_HEADER_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct generic_clause;
struct generic_map_aspect;
struct port_clause;
struct port_map_aspect;

struct block_header : x3::position_tagged
{
    generic_clause      generic_clause;     
    generic_map_aspect  generic_map_aspect; 
    port_clause         port_clause;        
    port_map_aspect     port_map_aspect;    
};


std::ostream& operator<<(std::ostream& os, block_header const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_HEADER_HPP_ */


/*
 * block_specification.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_SPECIFICATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_SPECIFICATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct architecture_name;
struct block_statement_label;
struct generate_statement_label;
struct index_specification;

struct block_specification :
    x3::variant<
        x3::forward_ast<architecture_name>,
        x3::forward_ast<block_statement_label>,
        x3::forward_ast<generate_statement_label>,
        x3::forward_ast<index_specification>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_SPECIFICATION_HPP_ */


/*
 * block_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct begin;
struct block;
struct block_declarative_part;
struct block_header;
struct block_label;
struct block_statement_part;
struct end;
struct guard_expression;
struct is;

struct block_statement : x3::position_tagged
{
    begin               begin;              
    block               block;              
    block_declarative_partblock_declarative_part;
    block_header        block_header;       
    block_label         block_label;        
    block_statement_partblock_statement_part;
    end                 end;                
    guard_expression    guard_expression;   
    is                  is;                 
};


std::ostream& operator<<(std::ostream& os, block_statement const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_STATEMENT_HPP_ */


/*
 * block_statement_part.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_STATEMENT_PART_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_STATEMENT_PART_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct concurrent_statement;

struct block_statement_part : x3::position_tagged
{
    concurrent_statementconcurrent_statement;
};


std::ostream& operator<<(std::ostream& os, block_statement_part const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_BLOCK_STATEMENT_PART_HPP_ */


/*
 * case_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CASE_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CASE_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct case;
struct case_label;
struct case_statement_alternative;
struct end;
struct expression;
struct is;

struct case_statement : x3::position_tagged
{
    case                case;               
    case_label          case_label;         
    case_statement_alternativecase_statement_alternative;
    end                 end;                
    expression          expression;         
    is                  is;                 
};


std::ostream& operator<<(std::ostream& os, case_statement const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CASE_STATEMENT_HPP_ */


/*
 * case_statement_alternative.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CASE_STATEMENT_ALTERNATIVE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CASE_STATEMENT_ALTERNATIVE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct choices;
struct sequence_of_statements;
struct when;

struct case_statement_alternative : x3::position_tagged
{
    choices             choices;            
    sequence_of_statementssequence_of_statements;
    when                when;               
};


std::ostream& operator<<(std::ostream& os, case_statement_alternative const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CASE_STATEMENT_ALTERNATIVE_HPP_ */


/*
 * character_literal.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHARACTER_LITERAL_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHARACTER_LITERAL_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct graphic_character;

struct character_literal : x3::position_tagged
{
    graphic_character   graphic_character;  
};


std::ostream& operator<<(std::ostream& os, character_literal const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHARACTER_LITERAL_HPP_ */


/*
 * choice.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHOICE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHOICE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct discrete_range;
struct element_simple_name;
struct others;
struct simple_expression;

struct choice :
    x3::variant<
        x3::forward_ast<discrete_range>,
        x3::forward_ast<element_simple_name>,
        x3::forward_ast<others>,
        x3::forward_ast<simple_expression>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHOICE_HPP_ */


/*
 * choices.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHOICES_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHOICES_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct choice;

struct choices :
    x3::variant<
        x3::forward_ast<choice>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CHOICES_HPP_ */


/*
 * component_configuration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_CONFIGURATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_CONFIGURATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct binding_indication;
struct block_configuration;
struct component_specification;
struct end;
struct for;

struct component_configuration : x3::position_tagged
{
    binding_indication  binding_indication; 
    block_configuration block_configuration;
    component_specificationcomponent_specification;
    end                 end;                
    for                 for;                
};


std::ostream& operator<<(std::ostream& os, component_configuration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_CONFIGURATION_HPP_ */


/*
 * component_declaration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_DECLARATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_DECLARATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct component;
struct component_simple_name;
struct end;
struct identifier;
struct is;
struct local_generic_clause;
struct local_port_clause;

struct component_declaration : x3::position_tagged
{
    component           component;          
    component_simple_namecomponent_simple_name;
    end                 end;                
    identifier          identifier;         
    is                  is;                 
    local_generic_clauselocal_generic_clause;
    local_port_clause   local_port_clause;  
};


std::ostream& operator<<(std::ostream& os, component_declaration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_DECLARATION_HPP_ */


/*
 * component_instantiation_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_INSTANTIATION_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_INSTANTIATION_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct generic_map_aspect;
struct instantiated_unit;
struct instantiation_label;
struct port_map_aspect;

struct component_instantiation_statement : x3::position_tagged
{
    generic_map_aspect  generic_map_aspect; 
    instantiated_unit   instantiated_unit;  
    instantiation_label instantiation_label;
    port_map_aspect     port_map_aspect;    
};


std::ostream& operator<<(std::ostream& os, component_instantiation_statement const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_INSTANTIATION_STATEMENT_HPP_ */


/*
 * component_specification.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_SPECIFICATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_SPECIFICATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct component_name;
struct instantiation_list;

struct component_specification : x3::position_tagged
{
    component_name      component_name;     
    instantiation_list  instantiation_list; 
};


std::ostream& operator<<(std::ostream& os, component_specification const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPONENT_SPECIFICATION_HPP_ */


/*
 * composite_type_definition.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPOSITE_TYPE_DEFINITION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPOSITE_TYPE_DEFINITION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct array_type_definition;
struct record_type_definition;

struct composite_type_definition :
    x3::variant<
        x3::forward_ast<array_type_definition>,
        x3::forward_ast<record_type_definition>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_COMPOSITE_TYPE_DEFINITION_HPP_ */


/*
 * concurrent_assertion_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_ASSERTION_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_ASSERTION_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct assertion;
struct label;
struct postponed;

struct concurrent_assertion_statement : x3::position_tagged
{
    assertion           assertion;          
    label               label;              
    postponed           postponed;          
};


std::ostream& operator<<(std::ostream& os, concurrent_assertion_statement const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_ASSERTION_STATEMENT_HPP_ */


/*
 * concurrent_procedure_call_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_PROCEDURE_CALL_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_PROCEDURE_CALL_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct label;
struct postponed;
struct procedure_call;

struct concurrent_procedure_call_statement : x3::position_tagged
{
    label               label;              
    postponed           postponed;          
    procedure_call      procedure_call;     
};


std::ostream& operator<<(std::ostream& os, concurrent_procedure_call_statement const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_PROCEDURE_CALL_STATEMENT_HPP_ */


/*
 * concurrent_signal_assignment_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct conditional_signal_assignment;
struct label;
struct postponed;
struct selected_signal_assignment;

struct concurrent_signal_assignment_statement :
    x3::variant<
        x3::forward_ast<conditional_signal_assignment>,
        x3::forward_ast<label>,
        x3::forward_ast<postponed>,
        x3::forward_ast<selected_signal_assignment>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT_HPP_ */


/*
 * concurrent_statement.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_STATEMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_STATEMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct block_statement;
struct component_instantiation_statement;
struct concurrent_assertion_statement;
struct concurrent_procedure_call_statement;
struct concurrent_signal_assignment_statement;
struct generate_statement;
struct process_statement;

struct concurrent_statement :
    x3::variant<
        x3::forward_ast<block_statement>,
        x3::forward_ast<component_instantiation_statement>,
        x3::forward_ast<concurrent_assertion_statement>,
        x3::forward_ast<concurrent_procedure_call_statement>,
        x3::forward_ast<concurrent_signal_assignment_statement>,
        x3::forward_ast<generate_statement>,
        x3::forward_ast<process_statement>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONCURRENT_STATEMENT_HPP_ */


/*
 * condition.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct boolean_expression;

struct condition : x3::position_tagged
{
    boolean_expression  boolean_expression; 
};


std::ostream& operator<<(std::ostream& os, condition const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITION_HPP_ */


/*
 * condition_clause.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITION_CLAUSE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITION_CLAUSE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct condition;
struct until;

struct condition_clause : x3::position_tagged
{
    condition           condition;          
    until               until;              
};


std::ostream& operator<<(std::ostream& os, condition_clause const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITION_CLAUSE_HPP_ */


/*
 * conditional_signal_assignment.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITIONAL_SIGNAL_ASSIGNMENT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITIONAL_SIGNAL_ASSIGNMENT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct conditional_waveforms;
struct options;
struct target;

struct conditional_signal_assignment : x3::position_tagged
{
    conditional_waveformsconditional_waveforms;
    options             options;            
    target              target;             
};


std::ostream& operator<<(std::ostream& os, conditional_signal_assignment const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITIONAL_SIGNAL_ASSIGNMENT_HPP_ */


/*
 * conditional_waveforms.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITIONAL_WAVEFORMS_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITIONAL_WAVEFORMS_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct condition;
struct else;
struct waveform;
struct when;

struct conditional_waveforms : x3::position_tagged
{
    condition           condition;          
    else                else;               
    waveform            waveform;           
    when                when;               
};


std::ostream& operator<<(std::ostream& os, conditional_waveforms const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONDITIONAL_WAVEFORMS_HPP_ */


/*
 * configuration_declaration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct block_configuration;
struct configuration;
struct configuration_declarative_part;
struct configuration_simple_name;
struct end;
struct entity_name;
struct identifier;
struct is;
struct of;

struct configuration_declaration : x3::position_tagged
{
    block_configuration block_configuration;
    configuration       configuration;      
    configuration_declarative_partconfiguration_declarative_part;
    configuration_simple_nameconfiguration_simple_name;
    end                 end;                
    entity_name         entity_name;        
    identifier          identifier;         
    is                  is;                 
    of                  of;                 
};


std::ostream& operator<<(std::ostream& os, configuration_declaration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATION_HPP_ */


/*
 * configuration_declarative_item.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATIVE_ITEM_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATIVE_ITEM_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct attribute_specification;
struct group_declaration;
struct use_clause;

struct configuration_declarative_item :
    x3::variant<
        x3::forward_ast<attribute_specification>,
        x3::forward_ast<group_declaration>,
        x3::forward_ast<use_clause>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATIVE_ITEM_HPP_ */


/*
 * configuration_declarative_part.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATIVE_PART_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATIVE_PART_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct configuration_declarative_item;

struct configuration_declarative_part : x3::position_tagged
{
    configuration_declarative_itemconfiguration_declarative_item;
};


std::ostream& operator<<(std::ostream& os, configuration_declarative_part const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_DECLARATIVE_PART_HPP_ */


/*
 * configuration_item.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_ITEM_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_ITEM_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct block_configuration;
struct component_configuration;

struct configuration_item :
    x3::variant<
        x3::forward_ast<block_configuration>,
        x3::forward_ast<component_configuration>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_ITEM_HPP_ */


/*
 * configuration_specification.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_SPECIFICATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_SPECIFICATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct binding_indication;
struct component_specification;
struct for;

struct configuration_specification : x3::position_tagged
{
    binding_indication  binding_indication; 
    component_specificationcomponent_specification;
    for                 for;                
};


std::ostream& operator<<(std::ostream& os, configuration_specification const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONFIGURATION_SPECIFICATION_HPP_ */


/*
 * constant_declaration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTANT_DECLARATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTANT_DECLARATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct constant;
struct expression;
struct identifier_list;
struct subtype_indication;

struct constant_declaration : x3::position_tagged
{
    constant            constant;           
    expression          expression;         
    identifier_list     identifier_list;    
    subtype_indication  subtype_indication; 
};


std::ostream& operator<<(std::ostream& os, constant_declaration const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTANT_DECLARATION_HPP_ */


/*
 * constrained_array_definition.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTRAINED_ARRAY_DEFINITION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTRAINED_ARRAY_DEFINITION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct array;
struct element_subtype_indication;
struct index_constraint;
struct of;

struct constrained_array_definition : x3::position_tagged
{
    array               array;              
    element_subtype_indicationelement_subtype_indication;
    index_constraint    index_constraint;   
    of                  of;                 
};


std::ostream& operator<<(std::ostream& os, constrained_array_definition const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTRAINED_ARRAY_DEFINITION_HPP_ */


/*
 * constraint.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTRAINT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTRAINT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct index_constraint;
struct range_constraint;

struct constraint :
    x3::variant<
        x3::forward_ast<index_constraint>,
        x3::forward_ast<range_constraint>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONSTRAINT_HPP_ */


/*
 * context_clause.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONTEXT_CLAUSE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONTEXT_CLAUSE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct context_item;

struct context_clause : x3::position_tagged
{
    context_item        context_item;       
};


std::ostream& operator<<(std::ostream& os, context_clause const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONTEXT_CLAUSE_HPP_ */


/*
 * context_item.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONTEXT_ITEM_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONTEXT_ITEM_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct library_clause;
struct use_clause;

struct context_item :
    x3::variant<
        x3::forward_ast<library_clause>,
        x3::forward_ast<use_clause>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_CONTEXT_ITEM_HPP_ */


/*
 * decimal_literal.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DECIMAL_LITERAL_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DECIMAL_LITERAL_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct exponent;
struct integer;

struct decimal_literal : x3::position_tagged
{
    exponent            exponent;           
    integer             integer;            
};


std::ostream& operator<<(std::ostream& os, decimal_literal const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DECIMAL_LITERAL_HPP_ */


/*
 * declaration.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DECLARATION_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DECLARATION_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct alias_declaration;
struct attribute_declaration;
struct component_declaration;
struct configuration_declaration;
struct entity_declaration;
struct group_declaration;
struct group_template_declaration;
struct interface_declaration;
struct object_declaration;
struct package_declaration;
struct subprogram_declaration;
struct subtype_declaration;
struct type_declaration;

struct declaration :
    x3::variant<
        x3::forward_ast<alias_declaration>,
        x3::forward_ast<attribute_declaration>,
        x3::forward_ast<component_declaration>,
        x3::forward_ast<configuration_declaration>,
        x3::forward_ast<entity_declaration>,
        x3::forward_ast<group_declaration>,
        x3::forward_ast<group_template_declaration>,
        x3::forward_ast<interface_declaration>,
        x3::forward_ast<object_declaration>,
        x3::forward_ast<package_declaration>,
        x3::forward_ast<subprogram_declaration>,
        x3::forward_ast<subtype_declaration>,
        x3::forward_ast<type_declaration>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DECLARATION_HPP_ */


/*
 * delay_mechanism.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DELAY_MECHANISM_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DELAY_MECHANISM_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct inertial;
struct reject;
struct time_expression;
struct transport;

struct delay_mechanism :
    x3::variant<
        x3::forward_ast<inertial>,
        x3::forward_ast<reject>,
        x3::forward_ast<time_expression>,
        x3::forward_ast<transport>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DELAY_MECHANISM_HPP_ */


/*
 * design_file.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGN_FILE_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGN_FILE_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct design_unit;

struct design_file : x3::position_tagged
{
    design_unit         design_unit;        
};


std::ostream& operator<<(std::ostream& os, design_file const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGN_FILE_HPP_ */


/*
 * design_unit.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGN_UNIT_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGN_UNIT_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <string>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct context_clause;
struct library_unit;

struct design_unit : x3::position_tagged
{
    context_clause      context_clause;     
    library_unit        library_unit;       
};


std::ostream& operator<<(std::ostream& os, design_unit const& node);


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGN_UNIT_HPP_ */


/*
 * designator.hpp
 *
 *  Created on: 18.03.2017
 *      Author: olaf
 */
        
#ifndef SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGNATOR_HPP_
#define SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGNATOR_HPP_

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <boost/spirit/home/x3/support/ast/variant.hpp>


namespace eda { namespace vhdl93 { namespace ast {


namespace x3 = boost::spirit::x3;


struct identifier;
struct operator_symbol;

struct designator :
    x3::variant<
        x3::forward_ast<identifier>,
        x3::forward_ast<operator_symbol>
    >
{
    using base_type::base_type;
    using base_type::operator=;
};


} } } // namespace eda.vhdl93.ast


#endif /* SOURCES_VHDL93_INCLUDE_EDA_VHDL93_AST_DESIGNATOR_HPP_ */
