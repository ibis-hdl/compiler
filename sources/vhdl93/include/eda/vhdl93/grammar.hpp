/*
 * grammar.hpp
 *
 *  Created on: 28.02.2017
 *      Author: olaf
 */

#ifndef INCLUDE_EDA_VHDL93_GRAMMAR_HPP_
#define INCLUDE_EDA_VHDL93_GRAMMAR_HPP_


#include <boost/spirit/home/x3.hpp>


namespace eda { namespace vhdl93 {

	namespace x3 = boost::spirit::x3;

	x3::rule<class abstract_literal> const abstract_literal { "abstract_literal" };
	x3::rule<class access_type_definition> const access_type_definition { "access_type_definition" };
	x3::rule<class actual_designator> const actual_designator { "actual_designator" };
	x3::rule<class actual_parameter_part> const actual_parameter_part { "actual_parameter_part" };
	x3::rule<class actual_part> const actual_part { "actual_part" };
	x3::rule<class adding_operator> const adding_operator { "adding_operator" };
	x3::rule<class aggregate> const aggregate { "aggregate" };
	x3::rule<class alias_declaration> const alias_declaration { "alias_declaration" };
	x3::rule<class alias_designator> const alias_designator { "alias_designator" };
	x3::rule<class allocator> const allocator { "allocator" };
	x3::rule<class architecture_body> const architecture_body { "architecture_body" };
	x3::rule<class architecture_declarative_part> const architecture_declarative_part { "architecture_declarative_part" };
	x3::rule<class architecture_statement_part> const architecture_statement_part { "architecture_statement_part" };
	x3::rule<class array_type_definition> const array_type_definition { "array_type_definition" };
	x3::rule<class assertion> const assertion { "assertion" };
	x3::rule<class assertion_statement> const assertion_statement { "assertion_statement" };
	x3::rule<class association_element> const association_element { "association_element" };
	x3::rule<class association_list> const association_list { "association_list" };
	x3::rule<class attribute_declaration> const attribute_declaration { "attribute_declaration" };
	x3::rule<class attribute_designator> const attribute_designator { "attribute_designator" };
	x3::rule<class attribute_name> const attribute_name { "attribute_name" };
	x3::rule<class attribute_specification> const attribute_specification { "attribute_specification" };
	x3::rule<class base> const base { "base" };
	x3::rule<class base_specifier> const base_specifier { "base_specifier" };
	x3::rule<class base_unit_declaration> const base_unit_declaration { "base_unit_declaration" };
	x3::rule<class based_integer> const based_integer { "based_integer" };
	x3::rule<class based_literal> const based_literal { "based_literal" };
	x3::rule<class basic_character> const basic_character { "basic_character" };
	x3::rule<class basic_graphic_character> const basic_graphic_character { "basic_graphic_character" };
	x3::rule<class basic_identifier> const basic_identifier { "basic_identifier" };
	x3::rule<class binding_indication> const binding_indication { "binding_indication" };
	x3::rule<class bit_string_literal> const bit_string_literal { "bit_string_literal" };
	x3::rule<class bit_value> const bit_value { "bit_value" };
	x3::rule<class block_configuration> const block_configuration { "block_configuration" };
	x3::rule<class block_declarative_item> const block_declarative_item { "block_declarative_item" };
	x3::rule<class block_declarative_part> const block_declarative_part { "block_declarative_part" };
	x3::rule<class block_header> const block_header { "block_header" };
	x3::rule<class block_specification> const block_specification { "block_specification" };
	x3::rule<class block_statement> const block_statement { "block_statement" };
	x3::rule<class block_statement_part> const block_statement_part { "block_statement_part" };
	x3::rule<class case_statement> const case_statement { "case_statement" };
	x3::rule<class case_statement_alternative> const case_statement_alternative { "case_statement_alternative" };
	x3::rule<class character_literal> const character_literal { "character_literal" };
	x3::rule<class choice> const choice { "choice" };
	x3::rule<class choices> const choices { "choices" };
	x3::rule<class component_configuration> const component_configuration { "component_configuration" };
	x3::rule<class component_declaration> const component_declaration { "component_declaration" };
	x3::rule<class component_instantiation_statement> const component_instantiation_statement { "component_instantiation_statement" };
	x3::rule<class component_specification> const component_specification { "component_specification" };
	x3::rule<class composite_type_definition> const composite_type_definition { "composite_type_definition" };
	x3::rule<class concurrent_assertion_statement> const concurrent_assertion_statement { "concurrent_assertion_statement" };
	x3::rule<class concurrent_procedure_call_statement> const concurrent_procedure_call_statement { "concurrent_procedure_call_statement" };
	x3::rule<class concurrent_signal_assignment_statement> const concurrent_signal_assignment_statement { "concurrent_signal_assignment_statement" };
	x3::rule<class concurrent_statement> const concurrent_statement { "concurrent_statement" };
	x3::rule<class condition> const condition { "condition" };
	x3::rule<class condition_clause> const condition_clause { "condition_clause" };
	x3::rule<class conditional_signal_assignment> const conditional_signal_assignment { "conditional_signal_assignment" };
	x3::rule<class conditional_waveforms> const conditional_waveforms { "conditional_waveforms" };
	x3::rule<class configuration_declaration> const configuration_declaration { "configuration_declaration" };
	x3::rule<class configuration_declarative_item> const configuration_declarative_item { "configuration_declarative_item" };
	x3::rule<class configuration_declarative_part> const configuration_declarative_part { "configuration_declarative_part" };
	x3::rule<class configuration_item> const configuration_item { "configuration_item" };
	x3::rule<class configuration_specification> const configuration_specification { "configuration_specification" };
	x3::rule<class constant_declaration> const constant_declaration { "constant_declaration" };
	x3::rule<class constrained_array_definition> const constrained_array_definition { "constrained_array_definition" };
	x3::rule<class constraint> const constraint { "constraint" };
	x3::rule<class context_clause> const context_clause { "context_clause" };
	x3::rule<class context_item> const context_item { "context_item" };
	x3::rule<class decimal_literal> const decimal_literal { "decimal_literal" };
	x3::rule<class declaration> const declaration { "declaration" };
	x3::rule<class delay_mechanism> const delay_mechanism { "delay_mechanism" };
	x3::rule<class design_file> const design_file { "design_file" };
	x3::rule<class design_unit> const design_unit { "design_unit" };
	x3::rule<class designator> const designator { "designator" };
	x3::rule<class direction> const direction { "direction" };
	x3::rule<class disconnection_specification> const disconnection_specification { "disconnection_specification" };
	x3::rule<class discrete_range> const discrete_range { "discrete_range" };
	x3::rule<class element_association> const element_association { "element_association" };
	x3::rule<class element_declaration> const element_declaration { "element_declaration" };
	x3::rule<class element_subtype_definition> const element_subtype_definition { "element_subtype_definition" };
	x3::rule<class entity_aspect> const entity_aspect { "entity_aspect" };
	x3::rule<class entity_class> const entity_class { "entity_class" };
	x3::rule<class entity_class_entry> const entity_class_entry { "entity_class_entry" };
	x3::rule<class entity_class_entry_list> const entity_class_entry_list { "entity_class_entry_list" };
	x3::rule<class entity_declaration> const entity_declaration { "entity_declaration" };
	x3::rule<class entity_declarative_item> const entity_declarative_item { "entity_declarative_item" };
	x3::rule<class entity_declarative_part> const entity_declarative_part { "entity_declarative_part" };
	x3::rule<class entity_designator> const entity_designator { "entity_designator" };
	x3::rule<class entity_header> const entity_header { "entity_header" };
	x3::rule<class entity_name_list> const entity_name_list { "entity_name_list" };
	x3::rule<class entity_specification> const entity_specification { "entity_specification" };
	x3::rule<class entity_statement> const entity_statement { "entity_statement" };
	x3::rule<class entity_statement_part> const entity_statement_part { "entity_statement_part" };
	x3::rule<class entity_tag> const entity_tag { "entity_tag" };
	x3::rule<class enumeration_literal> const enumeration_literal { "enumeration_literal" };
	x3::rule<class enumeration_type_definition> const enumeration_type_definition { "enumeration_type_definition" };
	x3::rule<class exit_statement> const exit_statement { "exit_statement" };
	x3::rule<class exponent> const exponent { "exponent" };
	x3::rule<class expression> const expression { "expression" };
	x3::rule<class extended_digit> const extended_digit { "extended_digit" };
	x3::rule<class extended_identifier> const extended_identifier { "extended_identifier" };
	x3::rule<class factor> const factor { "factor" };
	x3::rule<class file_declaration> const file_declaration { "file_declaration" };
	x3::rule<class file_logical_name> const file_logical_name { "file_logical_name" };
	x3::rule<class file_open_information> const file_open_information { "file_open_information" };
	x3::rule<class file_type_definition> const file_type_definition { "file_type_definition" };
	x3::rule<class formal_designator> const formal_designator { "formal_designator" };
	x3::rule<class formal_parameter_list> const formal_parameter_list { "formal_parameter_list" };
	x3::rule<class formal_part> const formal_part { "formal_part" };
	x3::rule<class full_type_declaration> const full_type_declaration { "full_type_declaration" };
	x3::rule<class function_call> const function_call { "function_call" };
	x3::rule<class generate_statement> const generate_statement { "generate_statement" };
	x3::rule<class generation_scheme> const generation_scheme { "generation_scheme" };
	x3::rule<class generic_clause> const generic_clause { "generic_clause" };
	x3::rule<class generic_list> const generic_list { "generic_list" };
	x3::rule<class generic_map_aspect> const generic_map_aspect { "generic_map_aspect" };
	x3::rule<class graphic_character> const graphic_character { "graphic_character" };
	x3::rule<class group_constituent> const group_constituent { "group_constituent" };
	x3::rule<class group_constituent_list> const group_constituent_list { "group_constituent_list" };
	x3::rule<class group_template_declaration> const group_template_declaration { "group_template_declaration" };
	x3::rule<class group_declaration> const group_declaration { "group_declaration" };
	x3::rule<class guarded_signal_specification> const guarded_signal_specification { "guarded_signal_specification" };
	x3::rule<class identifier> const identifier { "identifier" };
	x3::rule<class identifier_list> const identifier_list { "identifier_list" };
	x3::rule<class if_statement> const if_statement { "if_statement" };
	x3::rule<class incomplete_type_declaration> const incomplete_type_declaration { "incomplete_type_declaration" };
	x3::rule<class index_constraint> const index_constraint { "index_constraint" };
	x3::rule<class index_specification> const index_specification { "index_specification" };
	x3::rule<class index_subtype_definition> const index_subtype_definition { "index_subtype_definition" };
	x3::rule<class indexed_name> const indexed_name { "indexed_name" };
	x3::rule<class instantiated_unit> const instantiated_unit { "instantiated_unit" };
	x3::rule<class instantiation_list> const instantiation_list { "instantiation_list" };
	x3::rule<class integer> const integer { "integer" };
	x3::rule<class integer_type_definition> const integer_type_definition { "integer_type_definition" };
	x3::rule<class interface_constant_declaration> const interface_constant_declaration { "interface_constant_declaration" };
	x3::rule<class interface_declaration> const interface_declaration { "interface_declaration" };
	x3::rule<class interface_element> const interface_element { "interface_element" };
	x3::rule<class interface_file_declaration> const interface_file_declaration { "interface_file_declaration" };
	x3::rule<class interface_list> const interface_list { "interface_list" };
	x3::rule<class interface_signal_declaration> const interface_signal_declaration { "interface_signal_declaration" };
	x3::rule<class interface_variable_declaration> const interface_variable_declaration { "interface_variable_declaration" };
	x3::rule<class iteration_scheme> const iteration_scheme { "iteration_scheme" };
	x3::rule<class label> const label { "label" };
	x3::rule<class letter> const letter { "letter" };
	x3::rule<class letter_or_digit> const letter_or_digit { "letter_or_digit" };
	x3::rule<class library_clause> const library_clause { "library_clause" };
	x3::rule<class library_unit> const library_unit { "library_unit" };
	x3::rule<class literal> const literal { "literal" };
	x3::rule<class logical_name> const logical_name { "logical_name" };
	x3::rule<class logical_name_list> const logical_name_list { "logical_name_list" };
	x3::rule<class logical_operator> const logical_operator { "logical_operator" };
	x3::rule<class loop_statement> const loop_statement { "loop_statement" };
	x3::rule<class miscellaneous_operator> const miscellaneous_operator { "miscellaneous_operator" };
	x3::rule<class mode> const mode { "mode" };
	x3::rule<class multiplying_operator> const multiplying_operator { "multiplying_operator" };
	x3::rule<class name> const name { "name" };
	x3::rule<class next_statement> const next_statement { "next_statement" };
	x3::rule<class null_statement> const null_statement { "null_statement" };
	x3::rule<class numeric_literal> const numeric_literal { "numeric_literal" };
	x3::rule<class object_declaration> const object_declaration { "object_declaration" };
	x3::rule<class operator_symbol> const operator_symbol { "operator_symbol" };
	x3::rule<class options> const options { "options" };
	x3::rule<class package_body> const package_body { "package_body" };
	x3::rule<class package_body_declarative_item> const package_body_declarative_item { "package_body_declarative_item" };
	x3::rule<class package_body_declarative_part> const package_body_declarative_part { "package_body_declarative_part" };
	x3::rule<class package_declaration> const package_declaration { "package_declaration" };
	x3::rule<class package_declarative_item> const package_declarative_item { "package_declarative_item" };
	x3::rule<class package_declarative_part> const package_declarative_part { "package_declarative_part" };
	x3::rule<class parameter_specification> const parameter_specification { "parameter_specification" };
	x3::rule<class physical_literal> const physical_literal { "physical_literal" };
	x3::rule<class physical_type_definition> const physical_type_definition { "physical_type_definition" };
	x3::rule<class port_clause> const port_clause { "port_clause" };
	x3::rule<class port_list> const port_list { "port_list" };
	x3::rule<class port_map_aspect> const port_map_aspect { "port_map_aspect" };
	x3::rule<class prefix> const prefix { "prefix" };
	x3::rule<class primary> const primary { "primary" };
	x3::rule<class primary_unit> const primary_unit { "primary_unit" };
	x3::rule<class procedure_call> const procedure_call { "procedure_call" };
	x3::rule<class procedure_call_statement> const procedure_call_statement { "procedure_call_statement" };
	x3::rule<class process_declarative_item> const process_declarative_item { "process_declarative_item" };
	x3::rule<class process_declarative_part> const process_declarative_part { "process_declarative_part" };
	x3::rule<class process_statement> const process_statement { "process_statement" };
	x3::rule<class process_statement_part> const process_statement_part { "process_statement_part" };
	x3::rule<class qualified_expression> const qualified_expression { "qualified_expression" };
	x3::rule<class range> const range { "range" };
	x3::rule<class range_constraint> const range_constraint { "range_constraint" };
	x3::rule<class record_type_definition> const record_type_definition { "record_type_definition" };
	x3::rule<class relation> const relation { "relation" };
	x3::rule<class relational_operator> const relational_operator { "relational_operator" };
	x3::rule<class report_statement> const report_statement { "report_statement" };
	x3::rule<class return_statement> const return_statement { "return_statement" };
	x3::rule<class scalar_type_definition> const scalar_type_definition { "scalar_type_definition" };
	x3::rule<class secondary_unit> const secondary_unit { "secondary_unit" };
	x3::rule<class secondary_unit_declaration> const secondary_unit_declaration { "secondary_unit_declaration" };
	x3::rule<class selected_name> const selected_name { "selected_name" };
	x3::rule<class selected_signal_assignment> const selected_signal_assignment { "selected_signal_assignment" };
	x3::rule<class selected_waveforms> const selected_waveforms { "selected_waveforms" };
	x3::rule<class sensitivity_clause> const sensitivity_clause { "sensitivity_clause" };
	x3::rule<class sensitivity_list> const sensitivity_list { "sensitivity_list" };
	x3::rule<class sequence_of_statements> const sequence_of_statements { "sequence_of_statements" };
	x3::rule<class sequential_statement> const sequential_statement { "sequential_statement" };
	x3::rule<class shift_expression> const shift_expression { "shift_expression" };
	x3::rule<class shift_operator> const shift_operator { "shift_operator" };
	x3::rule<class sign> const sign { "sign" };
	x3::rule<class signal_assignment_statement> const signal_assignment_statement { "signal_assignment_statement" };
	x3::rule<class signal_declaration> const signal_declaration { "signal_declaration" };
	x3::rule<class signal_kind> const signal_kind { "signal_kind" };
	x3::rule<class signal_list> const signal_list { "signal_list" };
	x3::rule<class signature> const signature { "signature" };
	x3::rule<class simple_expression> const simple_expression { "simple_expression" };
	x3::rule<class simple_name> const simple_name { "simple_name" };
	x3::rule<class slice_name> const slice_name { "slice_name" };
	x3::rule<class string_literal> const string_literal { "string_literal" };
	x3::rule<class subprogram_body> const subprogram_body { "subprogram_body" };
	x3::rule<class subprogram_declaration> const subprogram_declaration { "subprogram_declaration" };
	x3::rule<class subprogram_declarative_item> const subprogram_declarative_item { "subprogram_declarative_item" };
	x3::rule<class subprogram_declarative_part> const subprogram_declarative_part { "subprogram_declarative_part" };
	x3::rule<class subprogram_kind> const subprogram_kind { "subprogram_kind" };
	x3::rule<class subprogram_specification> const subprogram_specification { "subprogram_specification" };
	x3::rule<class subprogram_statement_part> const subprogram_statement_part { "subprogram_statement_part" };
	x3::rule<class subtype_declaration> const subtype_declaration { "subtype_declaration" };
	x3::rule<class subtype_indication> const subtype_indication { "subtype_indication" };
	x3::rule<class suffix> const suffix { "suffix" };
	x3::rule<class target> const target { "target" };
	x3::rule<class term> const term { "term" };
	x3::rule<class timeout_clause> const timeout_clause { "timeout_clause" };
	x3::rule<class type_conversion> const type_conversion { "type_conversion" };
	x3::rule<class type_declaration> const type_declaration { "type_declaration" };
	x3::rule<class type_definition> const type_definition { "type_definition" };
	x3::rule<class type_mark> const type_mark { "type_mark" };
	x3::rule<class unconstrained_array_definition> const unconstrained_array_definition { "unconstrained_array_definition" };
	x3::rule<class use_clause> const use_clause { "use_clause" };
	x3::rule<class variable_assignment_statement> const variable_assignment_statement { "variable_assignment_statement" };
	x3::rule<class variable_declaration> const variable_declaration { "variable_declaration" };
	x3::rule<class wait_statement> const wait_statement { "wait_statement" };
	x3::rule<class waveform> const waveform { "waveform" };

} }


#endif /* INCLUDE_EDA_VHDL93_GRAMMAR_HPP_ */
