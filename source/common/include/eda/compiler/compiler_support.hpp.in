#pragma once

// DO NOT EDIT! GENERATED AUTOMATICALLY BY CMAKE!

// Variables as determined by CMake, see
// [How To Write Platform Checks](
//  https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Write-Platform-Checks)

#cmakedefine EDA_HAVE_BUILTIN_UNREACHABLE 1
#cmakedefine EDA_HAVE_BUILTIN_EXPECT 1
#cmakedefine EDA_HAVE_BUILTIN_ASSUME 1

#cmakedefine EDA_HAVE_EXPERIMENTAL_SOURCE_LOCATION 1


/* -----------------------------------------------------------------------------
 * Compiler intrinsics
 *
 * FixMe: I would expect those to be intrinsically tied to the optimizer in-situ, so
 * that moving them into wrapper functions would break them entirely.
 */

// use __builtin_expect to provide the compiler with branch prediction information
// \see [Other Built-in Functions Provided by GCC](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)
#if defined(EDA_HAVE_BUILTIN_EXPECT)
#define cxx_expect(x)       __builtin_expect(!!(x), 1)  // NOLINT(cppcoreguidelines-macro-usage)
#define cxx_expect_not(x)   __builtin_expect(!!(x), 0)  // NOLINT(cppcoreguidelines-macro-usage)
#else
#define cxx_expect(x)       x   // NOLINT(cppcoreguidelines-macro-usage)
#define cxx_expect_not(x)   x   // NOLINT(cppcoreguidelines-macro-usage)
#endif


#if defined(EDA_HAVE_BUILTIN_UNREACHABLE)
// \see [Other Built-in Functions Provided by GCC](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)
#define cxx_unreachable() __builtin_unreachable();   // NOLINT(cppcoreguidelines-macro-usage)
#elif defined(EDA_HAVE_BUILTIN_ASSUME)
// \see [__assume | Microsoft Docs](https://docs.microsoft.com/de-de/cpp/intrinsics/assume?view=msvc-160)
#define cxx_unreachable() __assume(0);  // NOLINT(cppcoreguidelines-macro-usage)
#else
#define cxx_unreachable() ((void)0)     // NOLINT(cppcoreguidelines-macro-usage)
#endif

