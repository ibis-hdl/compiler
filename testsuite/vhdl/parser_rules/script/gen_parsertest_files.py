#!/usr/bin/env python3
#
# Copyright (c) 2017-2025 Olaf (<ibis-hdl@users.noreply.github.com>).
# SPDX-License-Identifier: GPL-3.0-or-later
#

import os
import errno
from pathlib import Path

import argparse

import datetime
now = datetime.datetime.now()


class TestCase_Object:

    def __init__(self, test_case_name):

        self._testsuite_name = 'parser_rule'

        # This is the convention used by test case directory naming
        # failure test end with '_failure' inside directory name
        self._test_case_name = test_case_name

        [self._is_failure_test, self._test_case_base_name] = self._has_trailing_name(
            test_case_name, '_failure')

        self._parser_name = self._test_case_base_name
        self._attribute_name = self._test_case_base_name
        self._has_failure_test = False

    def set_testsuite_name(self, name):
        self._testsuite_name

    def get_testsuite_name(self):
        return self._testsuite_name

    def set_test_case_name(self, name):
        self._test_case_name = name

    def get_test_case_name(self):
        return self._test_case_name

    def set_parser_name(self, name):
        self._parser_name = name

    def get_parser_name(self):
        return self._parser_name

    def set_attribute_name(self, name):
        self._attribute_name = name

    def get_attribute_name(self):
        return self._attribute_name

    def set_has_failure_test(self, value=True):
        self._has_failure_test = value

    def get_has_failure_test(self):
        return self._has_failure_test

    testsuite_name = property(get_testsuite_name, set_testsuite_name)
    TestCase_Name = property(get_test_case_name, set_test_case_name)
    parser_name = property(get_parser_name, set_parser_name)
    attribute_name = property(get_attribute_name, set_attribute_name)
    has_failure_test = property(get_has_failure_test, set_has_failure_test)

    def is_failure_test_case(self):
        return self._is_failure_test

    def as_failure_test_case_name(self):
        """Helper to unify naming of failure test case names

        :return: The pure test case name with trailing '_failure' to indicate a failure test case.
        :rtype: str
        """
        return self._test_case_base_name + '_failure'

    def _has_trailing_name(self, test_case_name, string):
        """Check if there is a trailing 'string' at given name, this identifies a parser fail test.

        :param str test_case_name: The case case name, may have a '_failure' in the name.
        :param str string: The string to lookup at test_case_name
        :return: If True, it returns the clean ('string' pruned) name, otherwise the given name.
        :rtype: bool
        """

        if string in test_case_name:
            sz = len(string)
            return [True, test_case_name[:-sz]]
        return [False, test_case_name]


class GrammerAPI:
    def __init__(self, parser_list):
        self.script_name = os.path.basename(__file__)
        self.parser_list = parser_list
        self.api_namespaces = ['testsuite', 'vhdl::parser']
        # some test cases have no parsers here, they are embedded into grammar
        # so we have to filter out them
        self.skiplist = ['_failure', 'xxx',
                         # artifacts below??
                         'floating_type_definition',
                         'full_type_declaration',
                         'incomplete_type_declaration',
                         'integer_type_definition'
                         ]
        self.api_list = []
        for p in self.parser_list:
            if self.inSkipList(p):
                continue
            self.api_list.append(p)

    def cxx_declarations(self, file_name):
        """ Generate the API header to access the parsers

        :param file_name: The name inside the header's documentation
        :return: The header file contents
        :rtype: str
        """

        api_list = []
        for p in self.api_list:
            api_list.append("{name}_type {name}();".format(name=p))

        return """//
// Copyright (c) 2017-2025 Olaf (<ibis-hdl@users.noreply.github.com>).
// SPDX-License-Identifier: GPL-3.0-or-later
//

//
// {file}
//
// Generated by <{script}> on: {d}.{m}.{y}, do not edit!
//

#pragma once

#include <ibis/vhdl/parser/grammar_decl.hpp>

#include <ibis/namespace_alias.hpp> // IWYU pragma: keep

{namespace_bgn}

namespace parser = ibis::vhdl::parser;

// clang-format off
{api_fcn_decl}
// clang-format on

{namespace_end}
""".format(
            file=file_name + '.hpp',
            script=self.script_name,
            d=now.day,
            m=now.month,
            y=now.year,
            namespace_bgn=self.namespace_open(self.api_namespaces),
            api_fcn_decl='\n'.join(f"parser::{x}" for x in api_list),
            namespace_end=self.namespace_close(self.api_namespaces)
        )

    def cxxInstances(self, file_name):
        """ Generate the API instances to access the parsers

        :param file_name: The name inside the source's documentation
        :return: The source file contents
        :rtype: str
        """

        api_instances = []
        api_fcn_definitions = []

        for p in self.parser_list:
            api_instances.append(
                "BOOST_SPIRIT_INSTANTIATE({name}_type, iterator_type, context_type);"
                .format(name=p))
            api_fcn_definitions.append(
                """parser::{name}_type {name}() {{
    return ibis::vhdl::parser::{name};
}}
""".format(name=p))

        return """//
// Copyright (c) 2017-2025 Olaf (<ibis-hdl@users.noreply.github.com>).
// SPDX-License-Identifier: GPL-3.0-or-later
//

//
// {file}
//
// Generated by <{script}> on: {d}.{m}.{y}, do not edit!
//

#include <testsuite/vhdl/parser/rules.hpp>

#include <ibis/vhdl/parser/grammar_def.hpp>
#include <ibis/vhdl/parser/parser_config.hpp>

namespace ibis {{ namespace vhdl {{ namespace parser {{

// clang-format off
{instances}
// clang-format on

}} }} }} // namespace ibis.vhdl.parser


{namespace_api_bgn}

// clang-format off
{api_fcn_def}
// clang-format on

{namespace_api_end}
""".format(
            file=file_name + '.cpp',
            script=self.script_name,
            d=now.day,
            m=now.month,
            y=now.year,
            namespace_api_bgn=self.namespace_open(self.api_namespaces),
            instances='\n'.join(f"{x}" for x in api_instances),
            api_fcn_def='\n'.join(f"{x}" for x in api_fcn_definitions),
            namespace_api_end=self.namespace_close(self.api_namespaces)
        )

    def inSkipList(self, name):
        """check if name is inside the skip list.

        :param str name: The name to lookup. The name self may a grammar rule or '_failure' trigger.
        :return bool: returns True if name is inside the skip list, otherwise False.

        This is only usefull for the API header/source file generation!
        """
        for s in self.skiplist:
            if s in name:
                return True
        return False

    def namespace_open(self, namespaces):
        """Helper for opening namespace from namespace list.

        :param list namespaces: The list of names of the namespaces. They are building opening namespace list.
        :return str: A string of all opening namespaces with curly braces.
        """

        txt = ' '.join('namespace {name} {{'.format(
            name=name) for name in namespaces)
        return txt

    def namespace_close(self, namespaces):
        """Helper for closing namespace from namespace list.

        :param list namespaces: The list of names of the namespaces. They are building closing namespace list.
        :return str: A string of all closing namespaces with curly braces and comments.
        """

        braces = ' '.join('}' for name in namespaces)
        comment = '.'.join('{name}'.format(name=name) for name in namespaces)
        txt = braces + ' // namespace ' + comment
        return txt


class BoostTestGenerator:
    """
    Quick & Dirty python script to generate C++ skeletons for Boost.Test
    based on the directories given below 'test_case' to test the VHDL
    parser grammar.

    Over the time there where changes on the AST printer output format and
    macros used to generate the stuff, rewriting by hand isn't suitable.
    """

    def __init__(self):
        self.script_name = os.path.basename(__file__)
        self.ext_hxx = '.hpp'
        self.ext_cxx = '.cpp'
        self.testfile_postfix = '_test' + self.ext_cxx

    def create_cxx_test_file_name(self, testcase_obj):
        """
        Generate C++ file name to be used to write on filesystem.

        :param str testcase_obj: The object of the test case, used to create the base name of the file.
        :return: The C++ file name for the test case.
        """

        file_name = testcase_obj.TestCase_Name + self.testfile_postfix
        return file_name

    def create_cxx_test_file_path_name(self, output_dir, testcase_obj):
        """
        Generate C++ file name with full path to be used to write on filesystem.

        :param str output_dir: The directory to write the file into.
        :param testcase_obj test_case_name: The object of the test case, used to create the path name of the file.
        :return: The C++ file full path name for the test case.
        """

        file_name = self.create_cxx_test_file_name(testcase_obj)
        filepath_name = os.path.join(output_dir, file_name)
        return filepath_name

    def create_cxx_api_file_path_names(self, output_dir, base_name):
        """
        Generate API C++ header/source file names with full paths to be used to write on filesystem.

        :param str output_dir: The directory to write the file into.
        :param base_name test_case_name: The object of the test case, used to create the path name of the file.
        :return: The C++ header/source full path names for the test case.
        """

        hxx_filepath = os.path.join(output_dir, base_name + self.ext_hxx)
        cxx_filepath = os.path.join(output_dir, base_name + self.ext_cxx)
        return hxx_filepath, cxx_filepath

    def is_failure_test(self, test_case_name):
        """Check if there is a '_failure' into given name.

        :param str test_case_name: The case case name, may have a '_failure' in the name.
        :return: If True, it returns the clean ('_failure' pruned) name, otherwise the given name.

        This identifies a parser fail test.
        """

        if '_failure' in test_case_name:
            return [True, test_case_name[:-8]]
        return [False, test_case_name]

    def get_test_cases_from(self, input_dir):
        """Iterate over the input path to gather test_cases.

        :param str input_dir: The top level directory which contains the test cases.
        :return list: List of TestCase_Object gathered from directory listing.

        The list doesn't contain the failure test cases as such, but the base
        test case is tagged with this information. This allows to write both implementation
        bodies of UTF test into a file.

        It is assumed that the directory structure is:
        input_dir + test_case_a
                  + test_case_b
                  :
                  + test_case_n

        where each 'test_case' address a grammar rule and contains the real test data
        below this directory.
        """

        print('Search for test cases in %s' % input_dir)

        test_cases_dirlist = []

        # iterate over directory structure to gather the test cases, even failure tests
        for dirname, dirnames, filenames in os.walk(input_dir):
            for subdirname in dirnames:
                test_cases_dirlist.append(subdirname)

        #print('=> found: ', end=''); print(*test_cases_dirlist)

        test_cases = []

        # filter for special handled failure test
        for test_case in sorted(test_cases_dirlist):
            test_case_obj = TestCase_Object(test_case)
            if test_case_obj.is_failure_test_case():
                # discard ...
                continue
            # ... but tag the underlaying test case
            if test_case_obj.as_failure_test_case_name() in test_cases_dirlist:
                test_case_obj.has_failure_test = True
            test_cases.append(test_case_obj)

        return test_cases

    def cxx_file_header(self, testcase_obj):
        """Create a common C++ header

        :param testcase_obj: The test cas object
        """

        return """//
// Copyright (c) 2017-2025 Olaf (<ibis-hdl@users.noreply.github.com>).
// SPDX-License-Identifier: GPL-3.0-or-later
//

//
// @file {file}
//
// Generated by <{script}> on: {d}.{m}.{y}, do not edit!
//""".format(
            file=self.create_cxx_test_file_name(testcase_obj),
            script=self.script_name,
            d=now.day,
            m=now.month,
            y=now.year
        )

    def cxx_includes(self, testcase_obj):
        """Generate the headers required to compile.

        :param testcase_obj: The test cas object
        """

        return """
#include <ibis/vhdl/ast/node/{attr_name}.hpp>

#include <testsuite/vhdl/rules.hpp>
#include <testsuite/vhdl/parser/testing_parser.hpp>
#include <testsuite/vhdl/parser/failure_diagnostic_fixture.hpp>
#include <testsuite/vhdl/parser/dataset.hpp>

#include <testsuite/namespace_alias.hpp>  // IWYU pragma: keep

#include <boost/test/unit_test.hpp>  // IWYU pragma: keep
#include <boost/test/unit_test_suite.hpp>
#include <boost/test/data/test_case.hpp>
#include <boost/test/data/monomorphic/delayed.hpp>
#include <boost/test/tools/interface.hpp>  // BOOST_TEST()

""".format(
            attr_name=testcase_obj.attribute_name
        )

    def cxx_data_test_case(self, testcase_obj):
        """Generate the Boost UTF C++ body

        :param str testcase_obj: The test case object, used to label Boost's dataset test case.
        :return str: The contents holds the C++ body of the test.
        """

        template = """// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DATA_TEST_CASE({test_case}, // --
    utf_data::make_delayed<testsuite::vhdl::parser::dataset>("{test_case}"),  // --
    input, expected, test_case_name)
{{
    using namespace testsuite;
    using attribute_type = ast::{attr_name};
    auto parser = testsuite::vhdl::parser::{parser_name}();

    using testsuite::vhdl::parser::util::testing_parser;
    using namespace ibis::vhdl;

    testing_parser<attribute_type> const parse;
    auto [parse_ok, parse_result] = parse(input, parser, test_case_name);

    BOOST_TEST({bOk}parse_ok);
    if (!current_test_passing()) {{
        failure_closure(test_case_name, input, parse_result);
        return;
    }}

    BOOST_TEST(parse_result == expected, btt::per_element());
    failure_closure(test_case_name, input, expected, parse_result);
}}
"""

        body = template.format(
            test_case=testcase_obj.TestCase_Name,
            attr_name=testcase_obj.attribute_name,
            parser_name=testcase_obj.parser_name,
            bOk=''
        )

        body_failure = ''
        if testcase_obj.has_failure_test:
            body_failure = template.format(
                test_case=testcase_obj.as_failure_test_case_name(),
                attr_name=testcase_obj.attribute_name,
                parser_name=testcase_obj.parser_name,
                bOk='!'
            )

        if not body_failure:
            return body
        return body + '\n' + body_failure

    def cxx_test_file_contents(self, testcase_obj):
        """
        Assemble the contents of the test case file.

        :param testcase_obj: The test case object
        :return str: contents ready to write to file
        """

        return """{header}
{includes}

using testsuite::vhdl::parser::failure_diagnostic_fixture;

// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
BOOST_FIXTURE_TEST_SUITE(parser_rule, failure_diagnostic_fixture)

{datatest_case}
// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
BOOST_AUTO_TEST_SUITE_END()
""".format(
            header=self.cxx_file_header(testcase_obj),
            includes=self.cxx_includes(testcase_obj),
            testsuite_name=testcase_obj.testsuite_name,
            datatest_case=self.cxx_data_test_case(testcase_obj)
        )

    def write_test_file(self, filepath_name, cxx_contents):
        """
        Write the C++ Boost UTF test file.

        :param str filepath_name: The full file path be written into.
        :param cxx_contents: The C++ contens of the test case.
        """

        if not os.path.exists(os.path.dirname(filepath_name)):
            try:
                os.makedirs(os.path.dirname(filepath_name))
            except OSError as exc:  # Guard against race condition
                if exc.errno != errno.EEXIST:
                    raise

        with open(filepath_name, "w") as f:
            f.write(cxx_contents)

    def generate(self, args):
        """generate the Boost UTF test case files.

        :param str args: The arguments given from command line.
        """
        test_cases = self.get_test_cases_from(args.input_dir)
        cmake_source_list = []
        parser_list = []

        # iterate over the file list of test cases
        for testcase_obj in test_cases:

            print('generate {0}: <{1}> parser "{2}" with attr "{3}"'.format(
                testcase_obj.testsuite_name, testcase_obj.TestCase_Name,
                testcase_obj.parser_name, testcase_obj.attribute_name))

            cxx_contents = self.cxx_test_file_contents(testcase_obj)
            # print(cxx_contents)

            test_cxx = self.create_cxx_test_file_path_name(
                args.output_dir, testcase_obj)

            self.write_test_file(test_cxx, cxx_contents)

            cmake_source_list.append("{cxx}".format(
                cxx=os.path.join(
                    args.output_dir,
                    self.create_cxx_test_file_name(testcase_obj)))
            )

            # don't put failure tests to grammar rule's API
            if not testcase_obj.is_failure_test_case():
                parser_list.append(testcase_obj.parser_name)

        # print source file list for copy&paste to CMakeFiles
        print('set(TESTCASE_SOURCES')
        print('\n'.join('    ' + s for s in sorted(cmake_source_list)))
        print(')')

        # parser rule access API files, name leading '0' to sort on top on dir listing
        api_file_name = '0_rules'
        api = GrammerAPI(parser_list)
        # print(api.cxx_declarations(api_file_name))
        # print(api.cxxInstances(api_file_name))

        [api_hxx, api_cxx] = self.create_cxx_api_file_path_names(
            args.output_dir, api_file_name
        )

        # print(api_hxx)
        # print(api_cxx)
        self.write_test_file(api_hxx, api.cxx_declarations(api_file_name))
        self.write_test_file(api_cxx, api.cxxInstances(api_file_name))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Generate Boost UTF files for grammars.')
    parser.add_argument('--input-dir', '-i',
                        dest='input_dir',
                        default=os.path.join(os.getcwd(), 'test_case'),
                        help='top level input directory of test case files, separated in subdirectories for each grammar rule.')
    parser.add_argument('--output-dir', '-o',
                        dest='output_dir',
                        default='parser_test',
                        help='output directory where the resulting files are written into.')
    args = parser.parse_args()
    #print('input: ' + args.input_dir)
    #print('output: ' + args.output_dir)

    generator = BoostTestGenerator()
    generator.generate(args)
