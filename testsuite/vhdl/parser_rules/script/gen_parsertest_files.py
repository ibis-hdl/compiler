#!/usr/bin/env python3

import os, errno
from pathlib import Path

import argparse

import datetime
now = datetime.datetime.now()


class TestCase_Object:

    def __init__(self, test_case_name):

        self._testsuite_name = 'parser_rule'

        # This is the convention used by test case directory naming
        # failure test end with '_failure' inside directory name
        self._test_case_name = test_case_name

        [self._is_failure_test, self._test_case_base_name] = self._hasTrailingName(test_case_name, '_failure')

        self._parser_name = self._test_case_base_name
        self._attribute_name = self._test_case_base_name
        self._has_failure_test = False

    def set_Testsuite_Name(self, name):
        self._testsuite_name

    def get_Testsuite_Name(self):
        return self._testsuite_name

    def set_TestCase_Name(self, name):
        self._test_case_name = name

    def get_TestCase_Name(self):
        return self._test_case_name

    def set_Parser_Name(self, name):
        self._parser_name = name

    def get_Parser_Name(self):
        return self._parser_name

    def set_Attribute_Name(self, name):
        self._attribute_name = name

    def get_Attribute_Name(self):
        return self._attribute_name

    def set_HasFailureTest(self, value = True):
        self._has_failure_test = value

    def get_HasFailureTest(self):
        return self._has_failure_test


    Testsuite_Name = property(get_Testsuite_Name, set_Testsuite_Name)
    TestCase_Name = property(get_TestCase_Name, set_TestCase_Name)
    Parser_Name = property(get_Parser_Name, set_Parser_Name)
    Attribute_Name = property(get_Attribute_Name, set_Attribute_Name)
    HasFailureTest = property(get_HasFailureTest, set_HasFailureTest)

    def is_FailureTestCase(self):
        return self._is_failure_test

    def as_FailureTestCase_Name(self):
        """Helper to unify naming of failure test case names

        :return: The pure test case name with trailing '_failure' to indicate a failure test case.
        :rtype: str
        """
        return self._test_case_base_name + '_failure'

    def _hasTrailingName(self, test_case_name, string):
        """Check if there is a trailing 'string' at given name, this identifies a parser fail test.

        :param str test_case_name: The case case name, may have a '_failure' in the name.
        :param str string: The string to lookup at test_case_name
        :return: If True, it returns the clean ('string' pruned) name, otherwise the given name.
        :rtype: bool
        """

        if string in test_case_name:
            sz = len(string)
            return [True, test_case_name[:-sz]]
        else:
            return [False, test_case_name]


class GrammerAPI:
    def __init__(self, parser_list):
        self.script_name = os.path.basename(__file__)
        self.parser_list = parser_list
        self.api_namespaces = ['testsuite', 'vhdl_parser']
        # some test cases have no parsers here, they are embedded into grammar
        # so we have to filter out them
        self.skiplist = ['_failure', 'xxx',
                    # artifacts below??
                    'floating_type_definition',
                    'full_type_declaration',
                    'incomplete_type_declaration',
                    'integer_type_definition'
                    ]
        self.api_list = list()
        for p in self.parser_list:
            if self.inSkipList(p):
                continue
            self.api_list.append(p)


    def cxxDeclarations(self, file_name):
        """ Generate the API header to access the parsers

        :param file_name: The name inside the header's documentation
        :return: The header file contents
        :rtype: str
        """

        api_list=list()
        for p in self.api_list:
            api_list.append("{name}_type const& {name}();".format(name=p))

        return """
//
// {file}
//
// Generated by <{script}> on: {d}.{m}.{y}, do not edit!
//

#pragma once

#include <eda/vhdl/parser/grammar_decl.hpp>

#include <eda/namespace_alias.hpp> // IWYU pragma: keep

{namespace_bgn}

namespace parser = eda::vhdl::parser;

// clang-format off
{api_fcn_decl}
// clang-format on

{namespace_end}
""".format(
    file=file_name + '.hpp',
    script=self.script_name,
    d=now.day,
    m=now.month,
    y=now.year,
    namespace_bgn=self.namespace_open(self.api_namespaces),
    api_fcn_decl='\n'.join(f"parser::{x}" for x in api_list),
    namespace_end=self.namespace_close(self.api_namespaces)
)


    def cxxInstances(self, file_name):
        """ Generate the API instances to access the parsers

        :param file_name: The name inside the source's documentation
        :return: The source file contents
        :rtype: str
        """

        api_instances=list()
        api_fcn_definitions=list()

        for p in self.parser_list:
            api_instances.append(
                "BOOST_SPIRIT_INSTANTIATE({name}_type, iterator_type, context_type);"
                .format(name=p))
            api_fcn_definitions.append(
                """parser::{name}_type const& {name}() {{
    return eda::vhdl::parser::{name};
}}
""".format(name=p))

        return """
//
// {file}
//
// Generated by <{script}> on: {d}.{m}.{y}, do not edit!
//

#include <testsuite/vhdl_parser/rules.hpp>

#include <eda/vhdl/parser/grammar_def.hpp>
#include <eda/vhdl/parser/parser_config.hpp>

namespace eda {{ namespace vhdl {{ namespace parser {{

// clang-format off
{instances}
// clang-format on

}} }} }} // namespace eda.vhdl.parser


{namespace_api_bgn}

// clang-format off
{api_fcn_def}
// clang-format on

{namespace_api_end}
""".format(
    file=file_name + '.cpp',
    script=self.script_name,
    d=now.day,
    m=now.month,
    y=now.year,
    namespace_api_bgn=self.namespace_open(self.api_namespaces),
    instances='\n'.join(f"{x}" for x in api_instances),
    api_fcn_def='\n'.join(f"{x}" for x in api_fcn_definitions),
    namespace_api_end=self.namespace_close(self.api_namespaces)
)


    def inSkipList(self, name):
        """check if name is inside the skip list.

        :param str name: The name to lookup. The name self may a grammar rule or '_failure' trigger.
        :return bool: returns True if name is inside the skip list, otherwise False.

        This is only usefull for the API header/source file generation!
        """
        for s in self.skiplist:
            if s in name:
                return True
        return False


    def namespace_open(self, namespaces):
        """Helper for opening namespace from namespace list.

        :param list namespaces: The list of names of the namespaces. They are building opening namespace list.
        :return str: A string of all opening namespaces with curly braces.
        """

        txt=' '.join('namespace {name} {{'.format(name=name) for name in namespaces)
        return txt


    def namespace_close(self, namespaces):
        """Helper for closing namespace from namespace list.

        :param list namespaces: The list of names of the namespaces. They are building closing namespace list.
        :return str: A string of all closing namespaces with curly braces and comments.
        """

        braces=' '.join('}' for name in namespaces)
        comment='.'.join('{name}'.format(name=name) for name in namespaces)
        txt=braces + ' // namespace ' + comment
        return txt


class BoostTestGenerator:
    """
    Quick & Dirty python script to generate C++ skeletons for Boost.Test
    based on the directories given below 'test_case' to test the VHDL
    parser grammar.

    Over the time there where changes on the AST printer output format and
    macros used to generate the stuff, rewriting by hand isn't suitable.
    """
    def __init__(self):
        self.script_name = os.path.basename(__file__)
        self.ext_hxx = '.hpp'
        self.ext_cxx = '.cpp'
        self.testfile_postfix = '_test' + self.ext_cxx


    def create_cxxTestFileName(self, testcase_obj):
        """
        Generate C++ file name to be used to write on filesystem.

        :param str testcase_obj: The object of the test case, used to create the base name of the file.
        :return: The C++ file name for the test case.
        """

        file_name = testcase_obj.TestCase_Name + self.testfile_postfix
        return file_name


    def create_cxxTestFilePathName(self, output_dir, testcase_obj):
        """
        Generate C++ file name with full path to be used to write on filesystem.

        :param str output_dir: The directory to write the file into.
        :param testcase_obj test_case_name: The object of the test case, used to create the path name of the file.
        :return: The C++ file full path name for the test case.
        """

        file_name = self.create_cxxTestFileName(testcase_obj)
        filepath_name = os.path.join(output_dir, file_name)
        return filepath_name


    def create_cxxApiFilePathNames(self, output_dir, base_name):
        """
        Generate API C++ header/source file names with full paths to be used to write on filesystem.

        :param str output_dir: The directory to write the file into.
        :param base_name test_case_name: The object of the test case, used to create the path name of the file.
        :return: The C++ header/source full path names for the test case.
        """

        hxx_filepath = os.path.join(output_dir, base_name + self.ext_hxx)
        cxx_filepath = os.path.join(output_dir, base_name + self.ext_cxx)
        return hxx_filepath, cxx_filepath


    def isFailuretest(self, test_case_name):
        """Check if there is a '_failure' into given name.

        :param str test_case_name: The case case name, may have a '_failure' in the name.
        :return: If True, it returns the clean ('_failure' pruned) name, otherwise the given name.

        This identifies a parser fail test.
        """

        if '_failure' in test_case_name:
            return [True, test_case_name[:-8]]
        else:
            return [False, test_case_name]


    def getTestCasesFrom(self, input_dir):
        """Iterate over the input path to gather test_cases.

        :param str input_dir: The top level directory which contains the test cases.
        :return list: List of TestCase_Object gathered from directory listing.

        The list doesn't contain the failure test cases as such, but the base
        test case is tagged with this information. This allows to write both implementation
        bodies of UTF test into a file.

        It is assumed that the directory structure is:
        input_dir + test_case_a
                  + test_case_b
                  :
                  + test_case_n

        where each 'test_case' address a grammar rule and contains the real test data
        below this directory.
        """

        print('Search for test cases in %s' % input_dir)

        test_cases_dirlist = list()

        # iterate over directory structure to gather the test cases, even failure tests
        for dirname, dirnames, filenames in os.walk(input_dir):
            for subdirname in dirnames:
                test_cases_dirlist.append(subdirname)

        #print('=> found: ', end=''); print(*test_cases_dirlist)

        test_cases = list()

        # filter for special handled failure test
        for test_case in sorted(test_cases_dirlist):
            test_case_obj = TestCase_Object(test_case)
            if test_case_obj.is_FailureTestCase():
                # discard ...
                continue
            # ... but tag the underlaying test case
            if test_case_obj.as_FailureTestCase_Name() in test_cases_dirlist:
                test_case_obj.HasFailureTest = True
            test_cases.append(test_case_obj)

        return test_cases


    def cxxFileHeader(self, testcase_obj):
        """Create a common C++ header

        :param testcase_obj: The test cas object
        """

        return """//
// {file}
//
// Generated by <{script}> on: {d}.{m}.{y}, do not edit!
//""".format(
        file=self.create_cxxTestFileName(testcase_obj),
        script=self.script_name,
        d=now.day,
        m=now.month,
        y=now.year
    )


    def cxxIncludes(self, testcase_obj):
        """Generate the headers required to compile.

        :param testcase_obj: The test cas object
        """

        return """
#include <eda/vhdl/ast/node/{attr_name}.hpp>

#include <testsuite/common/data_set.hpp>
#include <testsuite/common/namespace_alias.hpp>  // IWYU pragma: keep

#include <testsuite/vhdl/rules.hpp>
#include <testsuite/vhdl_parser/testing_parser.hpp>
#include <testsuite/vhdl_parser/failure_diagnostic_fixture.hpp>

#include <boost/test/unit_test.hpp>  // IWYU pragma: keep
#include <boost/test/data/test_case.hpp>

#include <iostream>""".format(
        attr_name=testcase_obj.Attribute_Name
    )


    def cxxDataTestCase(self, testcase_obj):
        """Generate the Boost UTF C++ body

        :param str testcase_obj: The test case object, used to label Boost's dataset test case.
        :return str: The contents holds the C++ body of the test.
        """

        template = """// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DATA_TEST_CASE_F(  // --
    testsuite::vhdl_parser::util::failure_diagnostic_fixture, {test_case},
    utf_data::make_delayed<testsuite::dataset_loader>("test_case/{test_case}"),  // --
    input, expected, test_case_name)
{{
    using attribute_type = ast::{attr_name};
    auto const& parser = testsuite::vhdl_parser::{parser_name}();

    using testsuite::vhdl_parser::util::testing_parser;

    testing_parser<attribute_type> parse;
    auto [parse_ok, parse_result] = parse(input, parser, test_case_name);

    BOOST_TEST({bOk}parse_ok);
    if (!current_test_passing()) {{
        failure_closure(test_case_name, input, parse_result);
        return;
    }}

    BOOST_TEST(parse_result == expected, btt::per_element());
    failure_closure(test_case_name, input, parse_result);
}}
"""

        body = template.format(
            test_case=testcase_obj.TestCase_Name,
            attr_name=testcase_obj.Attribute_Name,
            parser_name=testcase_obj.Parser_Name,
            bOk=''
        )

        body_failure = ''
        if testcase_obj.HasFailureTest:
            body_failure = template.format(
                test_case=testcase_obj.as_FailureTestCase_Name(),
                attr_name=testcase_obj.Attribute_Name,
                parser_name=testcase_obj.Parser_Name,
                bOk='!'
            )

        if not body_failure:
            return body
        else:
            return body + '\n' + body_failure


    def cxxTestFileContents(self, testcase_obj):
        """
        Assemble the contents of the test case file.

        :param testcase_obj: The test case object
        :return str: contents ready to write to file
        """

        return """{header}
{includes}

// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
BOOST_AUTO_TEST_SUITE({testsuite_name})

{datatest_case}
// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
BOOST_AUTO_TEST_SUITE_END()
""".format(
    header=self.cxxFileHeader(testcase_obj),
    includes=self.cxxIncludes(testcase_obj),
    testsuite_name=testcase_obj.Testsuite_Name,
    datatest_case=self.cxxDataTestCase(testcase_obj)
)


    def writeTestFile(self, filepath_name, cxx_contents):
        """
        Write the C++ Boost UTF test file.

        :param str filepath_name: The full file path be written into.
        :param cxx_contents: The C++ contens of the test case.
        """

        if not os.path.exists(os.path.dirname(filepath_name)):
            try:
                os.makedirs(os.path.dirname(filepath_name))
            except OSError as exc: # Guard against race condition
                if exc.errno != errno.EEXIST:
                    raise

        with open(filepath_name, "w") as f:
            f.write(cxx_contents)


    def generate(self, args):
        """generate the Boost UTF test case files.

        :param str args: The arguments given from command line.
        """
        test_cases = self.getTestCasesFrom(args.input_dir)
        cmake_source_list = list()
        parser_list = list()

        # iterate over the file list of test cases
        for testcase_obj in test_cases:

            print('generate <{0} / {1}> parser "{2}" with attr "{3}"'.format(
                testcase_obj.Testsuite_Name, testcase_obj.TestCase_Name,
                testcase_obj.Parser_Name, testcase_obj.Attribute_Name))

            cxx_contents = self.cxxTestFileContents(testcase_obj)
            #print(cxx_contents)

            test_cxx = self.create_cxxTestFilePathName(
                args.output_dir, testcase_obj)

            self.writeTestFile(test_cxx, cxx_contents)

            cmake_source_list.append("{cxx}".format(
                cxx='src/' + self.create_cxxTestFileName(testcase_obj)))

            # don't put failure tests to grammar rule's API
            if not testcase_obj.is_FailureTestCase():
                parser_list.append(testcase_obj.Parser_Name)

        # print source file list for copy&paste to CMakeFiles
        print('set(TESTCASE_SOURCES')
        print('\n'.join('    ' + s for s in sorted(cmake_source_list)))
        print(')')

        # parser rule access API files, name leading '0' to sort on top on dir listing
        api_file_name = '0_rules'
        api = GrammerAPI(parser_list)
        #print(api.cxxDeclarations(api_file_name))
        #print(api.cxxInstances(api_file_name))

        [api_hxx, api_cxx] = self.create_cxxApiFilePathNames(
            args.output_dir, api_file_name
        )

        #print(api_hxx)
        #print(api_cxx)
        self.writeTestFile(api_hxx, api.cxxDeclarations(api_file_name))
        self.writeTestFile(api_cxx, api.cxxInstances(api_file_name))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Generate Boost UTF files for grammars.')
    parser.add_argument('--input-dir', '-I',
        dest='input_dir',
        default=os.path.join(os.getcwd(), 'test_case'),
        help='top level input directory of test case files, separated in subdirectories for each grammar rule.')
    parser.add_argument('--output-dir', '-O',
        dest='output_dir',
        default='parser_test',
        help='output directory where the resulting files are written into.')
    args = parser.parse_args()
    #print('input: ' + args.input_dir)
    #print('output: ' + args.output_dir)

    generator = BoostTestGenerator();
    generator.generate(args)
